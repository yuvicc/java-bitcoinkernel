// Generated by jextract

package org.bitcoinkernel.jextract;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class bitcoinkernel_h extends bitcoinkernel_h$shared {

    bitcoinkernel_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __has_safe_buffers = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_safe_buffers 0
     * }
     */
    public static int __has_safe_buffers() {
        return __has_safe_buffers;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 1
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {
        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {
        return _DARWIN_FEATURE_ONLY_VERS_1050;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int USE_CLANG_TYPES = (int)0L;
    /**
     * {@snippet lang=c :
     * #define USE_CLANG_TYPES 0
     * }
     */
    public static int USE_CLANG_TYPES() {
        return USE_CLANG_TYPES;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = bitcoinkernel_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = bitcoinkernel_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = bitcoinkernel_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = bitcoinkernel_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = bitcoinkernel_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t btck_SynchronizationState
     * }
     */
    public static final OfByte btck_SynchronizationState = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint8_t btck_Warning
     * }
     */
    public static final OfByte btck_Warning = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint8_t btck_ValidationMode
     * }
     */
    public static final OfByte btck_ValidationMode = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint32_t btck_BlockValidationResult
     * }
     */
    public static final OfInt btck_BlockValidationResult = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t btck_LogCategory
     * }
     */
    public static final OfByte btck_LogCategory = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint8_t btck_LogLevel
     * }
     */
    public static final OfByte btck_LogLevel = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint8_t btck_ScriptVerifyStatus
     * }
     */
    public static final OfByte btck_ScriptVerifyStatus = bitcoinkernel_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint32_t btck_ScriptVerificationFlags
     * }
     */
    public static final OfInt btck_ScriptVerificationFlags = bitcoinkernel_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint8_t btck_ChainType
     * }
     */
    public static final OfByte btck_ChainType = bitcoinkernel_h.C_CHAR;

    private static class btck_transaction_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Transaction *btck_transaction_create(const void *raw_transaction, size_t raw_transaction_len)
     * }
     */
    public static FunctionDescriptor btck_transaction_create$descriptor() {
        return btck_transaction_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Transaction *btck_transaction_create(const void *raw_transaction, size_t raw_transaction_len)
     * }
     */
    public static MethodHandle btck_transaction_create$handle() {
        return btck_transaction_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Transaction *btck_transaction_create(const void *raw_transaction, size_t raw_transaction_len)
     * }
     */
    public static MemorySegment btck_transaction_create$address() {
        return btck_transaction_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Transaction *btck_transaction_create(const void *raw_transaction, size_t raw_transaction_len)
     * }
     */
    public static MemorySegment btck_transaction_create(MemorySegment raw_transaction, long raw_transaction_len) {
        var mh$ = btck_transaction_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_create", raw_transaction, raw_transaction_len);
            }
            return (MemorySegment)mh$.invokeExact(raw_transaction, raw_transaction_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Transaction *btck_transaction_copy(const btck_Transaction *transaction)
     * }
     */
    public static FunctionDescriptor btck_transaction_copy$descriptor() {
        return btck_transaction_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Transaction *btck_transaction_copy(const btck_Transaction *transaction)
     * }
     */
    public static MethodHandle btck_transaction_copy$handle() {
        return btck_transaction_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Transaction *btck_transaction_copy(const btck_Transaction *transaction)
     * }
     */
    public static MemorySegment btck_transaction_copy$address() {
        return btck_transaction_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Transaction *btck_transaction_copy(const btck_Transaction *transaction)
     * }
     */
    public static MemorySegment btck_transaction_copy(MemorySegment transaction) {
        var mh$ = btck_transaction_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_copy", transaction);
            }
            return (MemorySegment)mh$.invokeExact(transaction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_to_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_to_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_transaction_to_bytes(const btck_Transaction *transaction, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static FunctionDescriptor btck_transaction_to_bytes$descriptor() {
        return btck_transaction_to_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_transaction_to_bytes(const btck_Transaction *transaction, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static MethodHandle btck_transaction_to_bytes$handle() {
        return btck_transaction_to_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_transaction_to_bytes(const btck_Transaction *transaction, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static MemorySegment btck_transaction_to_bytes$address() {
        return btck_transaction_to_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_transaction_to_bytes(const btck_Transaction *transaction, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static int btck_transaction_to_bytes(MemorySegment transaction, MemorySegment writer, MemorySegment user_data) {
        var mh$ = btck_transaction_to_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_to_bytes", transaction, writer, user_data);
            }
            return (int)mh$.invokeExact(transaction, writer, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_count_outputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_LONG,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_count_outputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t btck_transaction_count_outputs(const btck_Transaction *transaction)
     * }
     */
    public static FunctionDescriptor btck_transaction_count_outputs$descriptor() {
        return btck_transaction_count_outputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t btck_transaction_count_outputs(const btck_Transaction *transaction)
     * }
     */
    public static MethodHandle btck_transaction_count_outputs$handle() {
        return btck_transaction_count_outputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t btck_transaction_count_outputs(const btck_Transaction *transaction)
     * }
     */
    public static MemorySegment btck_transaction_count_outputs$address() {
        return btck_transaction_count_outputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t btck_transaction_count_outputs(const btck_Transaction *transaction)
     * }
     */
    public static long btck_transaction_count_outputs(MemorySegment transaction) {
        var mh$ = btck_transaction_count_outputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_count_outputs", transaction);
            }
            return (long)mh$.invokeExact(transaction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_get_output_at {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_get_output_at");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_TransactionOutput *btck_transaction_get_output_at(const btck_Transaction *transaction, size_t output_index)
     * }
     */
    public static FunctionDescriptor btck_transaction_get_output_at$descriptor() {
        return btck_transaction_get_output_at.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_TransactionOutput *btck_transaction_get_output_at(const btck_Transaction *transaction, size_t output_index)
     * }
     */
    public static MethodHandle btck_transaction_get_output_at$handle() {
        return btck_transaction_get_output_at.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_TransactionOutput *btck_transaction_get_output_at(const btck_Transaction *transaction, size_t output_index)
     * }
     */
    public static MemorySegment btck_transaction_get_output_at$address() {
        return btck_transaction_get_output_at.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_TransactionOutput *btck_transaction_get_output_at(const btck_Transaction *transaction, size_t output_index)
     * }
     */
    public static MemorySegment btck_transaction_get_output_at(MemorySegment transaction, long output_index) {
        var mh$ = btck_transaction_get_output_at.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_get_output_at", transaction, output_index);
            }
            return (MemorySegment)mh$.invokeExact(transaction, output_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_get_input_at {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_get_input_at");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_TransactionInput *btck_transaction_get_input_at(const btck_Transaction *transaction, size_t input_index)
     * }
     */
    public static FunctionDescriptor btck_transaction_get_input_at$descriptor() {
        return btck_transaction_get_input_at.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_TransactionInput *btck_transaction_get_input_at(const btck_Transaction *transaction, size_t input_index)
     * }
     */
    public static MethodHandle btck_transaction_get_input_at$handle() {
        return btck_transaction_get_input_at.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_TransactionInput *btck_transaction_get_input_at(const btck_Transaction *transaction, size_t input_index)
     * }
     */
    public static MemorySegment btck_transaction_get_input_at$address() {
        return btck_transaction_get_input_at.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_TransactionInput *btck_transaction_get_input_at(const btck_Transaction *transaction, size_t input_index)
     * }
     */
    public static MemorySegment btck_transaction_get_input_at(MemorySegment transaction, long input_index) {
        var mh$ = btck_transaction_get_input_at.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_get_input_at", transaction, input_index);
            }
            return (MemorySegment)mh$.invokeExact(transaction, input_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_count_inputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_LONG,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_count_inputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t btck_transaction_count_inputs(const btck_Transaction *transaction)
     * }
     */
    public static FunctionDescriptor btck_transaction_count_inputs$descriptor() {
        return btck_transaction_count_inputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t btck_transaction_count_inputs(const btck_Transaction *transaction)
     * }
     */
    public static MethodHandle btck_transaction_count_inputs$handle() {
        return btck_transaction_count_inputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t btck_transaction_count_inputs(const btck_Transaction *transaction)
     * }
     */
    public static MemorySegment btck_transaction_count_inputs$address() {
        return btck_transaction_count_inputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t btck_transaction_count_inputs(const btck_Transaction *transaction)
     * }
     */
    public static long btck_transaction_count_inputs(MemorySegment transaction) {
        var mh$ = btck_transaction_count_inputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_count_inputs", transaction);
            }
            return (long)mh$.invokeExact(transaction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_get_txid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_get_txid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_Txid *btck_transaction_get_txid(const btck_Transaction *transaction)
     * }
     */
    public static FunctionDescriptor btck_transaction_get_txid$descriptor() {
        return btck_transaction_get_txid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_Txid *btck_transaction_get_txid(const btck_Transaction *transaction)
     * }
     */
    public static MethodHandle btck_transaction_get_txid$handle() {
        return btck_transaction_get_txid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_Txid *btck_transaction_get_txid(const btck_Transaction *transaction)
     * }
     */
    public static MemorySegment btck_transaction_get_txid$address() {
        return btck_transaction_get_txid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_Txid *btck_transaction_get_txid(const btck_Transaction *transaction)
     * }
     */
    public static MemorySegment btck_transaction_get_txid(MemorySegment transaction) {
        var mh$ = btck_transaction_get_txid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_get_txid", transaction);
            }
            return (MemorySegment)mh$.invokeExact(transaction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_transaction_destroy(btck_Transaction *transaction)
     * }
     */
    public static FunctionDescriptor btck_transaction_destroy$descriptor() {
        return btck_transaction_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_transaction_destroy(btck_Transaction *transaction)
     * }
     */
    public static MethodHandle btck_transaction_destroy$handle() {
        return btck_transaction_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_transaction_destroy(btck_Transaction *transaction)
     * }
     */
    public static MemorySegment btck_transaction_destroy$address() {
        return btck_transaction_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_transaction_destroy(btck_Transaction *transaction)
     * }
     */
    public static void btck_transaction_destroy(MemorySegment transaction) {
        var mh$ = btck_transaction_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_destroy", transaction);
            }
            mh$.invokeExact(transaction);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_script_pubkey_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_script_pubkey_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_ScriptPubkey *btck_script_pubkey_create(const void *script_pubkey, size_t script_pubkey_len)
     * }
     */
    public static FunctionDescriptor btck_script_pubkey_create$descriptor() {
        return btck_script_pubkey_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_ScriptPubkey *btck_script_pubkey_create(const void *script_pubkey, size_t script_pubkey_len)
     * }
     */
    public static MethodHandle btck_script_pubkey_create$handle() {
        return btck_script_pubkey_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_ScriptPubkey *btck_script_pubkey_create(const void *script_pubkey, size_t script_pubkey_len)
     * }
     */
    public static MemorySegment btck_script_pubkey_create$address() {
        return btck_script_pubkey_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_ScriptPubkey *btck_script_pubkey_create(const void *script_pubkey, size_t script_pubkey_len)
     * }
     */
    public static MemorySegment btck_script_pubkey_create(MemorySegment script_pubkey, long script_pubkey_len) {
        var mh$ = btck_script_pubkey_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_script_pubkey_create", script_pubkey, script_pubkey_len);
            }
            return (MemorySegment)mh$.invokeExact(script_pubkey, script_pubkey_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_script_pubkey_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_script_pubkey_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_ScriptPubkey *btck_script_pubkey_copy(const btck_ScriptPubkey *script_pubkey)
     * }
     */
    public static FunctionDescriptor btck_script_pubkey_copy$descriptor() {
        return btck_script_pubkey_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_ScriptPubkey *btck_script_pubkey_copy(const btck_ScriptPubkey *script_pubkey)
     * }
     */
    public static MethodHandle btck_script_pubkey_copy$handle() {
        return btck_script_pubkey_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_ScriptPubkey *btck_script_pubkey_copy(const btck_ScriptPubkey *script_pubkey)
     * }
     */
    public static MemorySegment btck_script_pubkey_copy$address() {
        return btck_script_pubkey_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_ScriptPubkey *btck_script_pubkey_copy(const btck_ScriptPubkey *script_pubkey)
     * }
     */
    public static MemorySegment btck_script_pubkey_copy(MemorySegment script_pubkey) {
        var mh$ = btck_script_pubkey_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_script_pubkey_copy", script_pubkey);
            }
            return (MemorySegment)mh$.invokeExact(script_pubkey);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_script_pubkey_verify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG_LONG,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG,
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_script_pubkey_verify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_script_pubkey_verify(const btck_ScriptPubkey *script_pubkey, int64_t amount, const btck_Transaction *tx_to, const btck_TransactionOutput **spent_outputs, size_t spent_outputs_len, unsigned int input_index, btck_ScriptVerificationFlags flags, btck_ScriptVerifyStatus *status)
     * }
     */
    public static FunctionDescriptor btck_script_pubkey_verify$descriptor() {
        return btck_script_pubkey_verify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_script_pubkey_verify(const btck_ScriptPubkey *script_pubkey, int64_t amount, const btck_Transaction *tx_to, const btck_TransactionOutput **spent_outputs, size_t spent_outputs_len, unsigned int input_index, btck_ScriptVerificationFlags flags, btck_ScriptVerifyStatus *status)
     * }
     */
    public static MethodHandle btck_script_pubkey_verify$handle() {
        return btck_script_pubkey_verify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_script_pubkey_verify(const btck_ScriptPubkey *script_pubkey, int64_t amount, const btck_Transaction *tx_to, const btck_TransactionOutput **spent_outputs, size_t spent_outputs_len, unsigned int input_index, btck_ScriptVerificationFlags flags, btck_ScriptVerifyStatus *status)
     * }
     */
    public static MemorySegment btck_script_pubkey_verify$address() {
        return btck_script_pubkey_verify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_script_pubkey_verify(const btck_ScriptPubkey *script_pubkey, int64_t amount, const btck_Transaction *tx_to, const btck_TransactionOutput **spent_outputs, size_t spent_outputs_len, unsigned int input_index, btck_ScriptVerificationFlags flags, btck_ScriptVerifyStatus *status)
     * }
     */
    public static int btck_script_pubkey_verify(MemorySegment script_pubkey, long amount, MemorySegment tx_to, MemorySegment spent_outputs, long spent_outputs_len, int input_index, int flags, MemorySegment status) {
        var mh$ = btck_script_pubkey_verify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_script_pubkey_verify", script_pubkey, amount, tx_to, spent_outputs, spent_outputs_len, input_index, flags, status);
            }
            return (int)mh$.invokeExact(script_pubkey, amount, tx_to, spent_outputs, spent_outputs_len, input_index, flags, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_script_pubkey_to_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_script_pubkey_to_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_script_pubkey_to_bytes(const btck_ScriptPubkey *script_pubkey, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static FunctionDescriptor btck_script_pubkey_to_bytes$descriptor() {
        return btck_script_pubkey_to_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_script_pubkey_to_bytes(const btck_ScriptPubkey *script_pubkey, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static MethodHandle btck_script_pubkey_to_bytes$handle() {
        return btck_script_pubkey_to_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_script_pubkey_to_bytes(const btck_ScriptPubkey *script_pubkey, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static MemorySegment btck_script_pubkey_to_bytes$address() {
        return btck_script_pubkey_to_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_script_pubkey_to_bytes(const btck_ScriptPubkey *script_pubkey, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static int btck_script_pubkey_to_bytes(MemorySegment script_pubkey, MemorySegment writer, MemorySegment user_data) {
        var mh$ = btck_script_pubkey_to_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_script_pubkey_to_bytes", script_pubkey, writer, user_data);
            }
            return (int)mh$.invokeExact(script_pubkey, writer, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_script_pubkey_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_script_pubkey_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_script_pubkey_destroy(btck_ScriptPubkey *script_pubkey)
     * }
     */
    public static FunctionDescriptor btck_script_pubkey_destroy$descriptor() {
        return btck_script_pubkey_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_script_pubkey_destroy(btck_ScriptPubkey *script_pubkey)
     * }
     */
    public static MethodHandle btck_script_pubkey_destroy$handle() {
        return btck_script_pubkey_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_script_pubkey_destroy(btck_ScriptPubkey *script_pubkey)
     * }
     */
    public static MemorySegment btck_script_pubkey_destroy$address() {
        return btck_script_pubkey_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_script_pubkey_destroy(btck_ScriptPubkey *script_pubkey)
     * }
     */
    public static void btck_script_pubkey_destroy(MemorySegment script_pubkey) {
        var mh$ = btck_script_pubkey_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_script_pubkey_destroy", script_pubkey);
            }
            mh$.invokeExact(script_pubkey);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_output_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_output_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_TransactionOutput *btck_transaction_output_create(const btck_ScriptPubkey *script_pubkey, int64_t amount)
     * }
     */
    public static FunctionDescriptor btck_transaction_output_create$descriptor() {
        return btck_transaction_output_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_TransactionOutput *btck_transaction_output_create(const btck_ScriptPubkey *script_pubkey, int64_t amount)
     * }
     */
    public static MethodHandle btck_transaction_output_create$handle() {
        return btck_transaction_output_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_TransactionOutput *btck_transaction_output_create(const btck_ScriptPubkey *script_pubkey, int64_t amount)
     * }
     */
    public static MemorySegment btck_transaction_output_create$address() {
        return btck_transaction_output_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_TransactionOutput *btck_transaction_output_create(const btck_ScriptPubkey *script_pubkey, int64_t amount)
     * }
     */
    public static MemorySegment btck_transaction_output_create(MemorySegment script_pubkey, long amount) {
        var mh$ = btck_transaction_output_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_output_create", script_pubkey, amount);
            }
            return (MemorySegment)mh$.invokeExact(script_pubkey, amount);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_output_get_script_pubkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_output_get_script_pubkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_ScriptPubkey *btck_transaction_output_get_script_pubkey(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static FunctionDescriptor btck_transaction_output_get_script_pubkey$descriptor() {
        return btck_transaction_output_get_script_pubkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_ScriptPubkey *btck_transaction_output_get_script_pubkey(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static MethodHandle btck_transaction_output_get_script_pubkey$handle() {
        return btck_transaction_output_get_script_pubkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_ScriptPubkey *btck_transaction_output_get_script_pubkey(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static MemorySegment btck_transaction_output_get_script_pubkey$address() {
        return btck_transaction_output_get_script_pubkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_ScriptPubkey *btck_transaction_output_get_script_pubkey(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static MemorySegment btck_transaction_output_get_script_pubkey(MemorySegment transaction_output) {
        var mh$ = btck_transaction_output_get_script_pubkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_output_get_script_pubkey", transaction_output);
            }
            return (MemorySegment)mh$.invokeExact(transaction_output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_output_get_amount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_LONG_LONG,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_output_get_amount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t btck_transaction_output_get_amount(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static FunctionDescriptor btck_transaction_output_get_amount$descriptor() {
        return btck_transaction_output_get_amount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t btck_transaction_output_get_amount(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static MethodHandle btck_transaction_output_get_amount$handle() {
        return btck_transaction_output_get_amount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t btck_transaction_output_get_amount(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static MemorySegment btck_transaction_output_get_amount$address() {
        return btck_transaction_output_get_amount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t btck_transaction_output_get_amount(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static long btck_transaction_output_get_amount(MemorySegment transaction_output) {
        var mh$ = btck_transaction_output_get_amount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_output_get_amount", transaction_output);
            }
            return (long)mh$.invokeExact(transaction_output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_output_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_output_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_TransactionOutput *btck_transaction_output_copy(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static FunctionDescriptor btck_transaction_output_copy$descriptor() {
        return btck_transaction_output_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_TransactionOutput *btck_transaction_output_copy(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static MethodHandle btck_transaction_output_copy$handle() {
        return btck_transaction_output_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_TransactionOutput *btck_transaction_output_copy(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static MemorySegment btck_transaction_output_copy$address() {
        return btck_transaction_output_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_TransactionOutput *btck_transaction_output_copy(const btck_TransactionOutput *transaction_output)
     * }
     */
    public static MemorySegment btck_transaction_output_copy(MemorySegment transaction_output) {
        var mh$ = btck_transaction_output_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_output_copy", transaction_output);
            }
            return (MemorySegment)mh$.invokeExact(transaction_output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_output_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_output_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_transaction_output_destroy(btck_TransactionOutput *transaction_output)
     * }
     */
    public static FunctionDescriptor btck_transaction_output_destroy$descriptor() {
        return btck_transaction_output_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_transaction_output_destroy(btck_TransactionOutput *transaction_output)
     * }
     */
    public static MethodHandle btck_transaction_output_destroy$handle() {
        return btck_transaction_output_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_transaction_output_destroy(btck_TransactionOutput *transaction_output)
     * }
     */
    public static MemorySegment btck_transaction_output_destroy$address() {
        return btck_transaction_output_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_transaction_output_destroy(btck_TransactionOutput *transaction_output)
     * }
     */
    public static void btck_transaction_output_destroy(MemorySegment transaction_output) {
        var mh$ = btck_transaction_output_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_output_destroy", transaction_output);
            }
            mh$.invokeExact(transaction_output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void btck_logging_disable()
     * }
     */
    public static class btck_logging_disable {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_logging_disable");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private btck_logging_disable(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void btck_logging_disable()
         * }
         */
        public static btck_logging_disable makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new btck_logging_disable(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("btck_logging_disable", x0);
                }
                 spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class btck_logging_set_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            btck_LoggingOptions.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_logging_set_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_logging_set_options(const btck_LoggingOptions options)
     * }
     */
    public static FunctionDescriptor btck_logging_set_options$descriptor() {
        return btck_logging_set_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_logging_set_options(const btck_LoggingOptions options)
     * }
     */
    public static MethodHandle btck_logging_set_options$handle() {
        return btck_logging_set_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_logging_set_options(const btck_LoggingOptions options)
     * }
     */
    public static MemorySegment btck_logging_set_options$address() {
        return btck_logging_set_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_logging_set_options(const btck_LoggingOptions options)
     * }
     */
    public static void btck_logging_set_options(MemorySegment options) {
        var mh$ = btck_logging_set_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_logging_set_options", options);
            }
            mh$.invokeExact(options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_logging_set_level_category {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_CHAR,
            bitcoinkernel_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_logging_set_level_category");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_logging_set_level_category(btck_LogCategory category, btck_LogLevel level)
     * }
     */
    public static FunctionDescriptor btck_logging_set_level_category$descriptor() {
        return btck_logging_set_level_category.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_logging_set_level_category(btck_LogCategory category, btck_LogLevel level)
     * }
     */
    public static MethodHandle btck_logging_set_level_category$handle() {
        return btck_logging_set_level_category.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_logging_set_level_category(btck_LogCategory category, btck_LogLevel level)
     * }
     */
    public static MemorySegment btck_logging_set_level_category$address() {
        return btck_logging_set_level_category.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_logging_set_level_category(btck_LogCategory category, btck_LogLevel level)
     * }
     */
    public static void btck_logging_set_level_category(byte category, byte level) {
        var mh$ = btck_logging_set_level_category.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_logging_set_level_category", category, level);
            }
            mh$.invokeExact(category, level);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_logging_enable_category {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_logging_enable_category");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_logging_enable_category(btck_LogCategory category)
     * }
     */
    public static FunctionDescriptor btck_logging_enable_category$descriptor() {
        return btck_logging_enable_category.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_logging_enable_category(btck_LogCategory category)
     * }
     */
    public static MethodHandle btck_logging_enable_category$handle() {
        return btck_logging_enable_category.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_logging_enable_category(btck_LogCategory category)
     * }
     */
    public static MemorySegment btck_logging_enable_category$address() {
        return btck_logging_enable_category.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_logging_enable_category(btck_LogCategory category)
     * }
     */
    public static void btck_logging_enable_category(byte category) {
        var mh$ = btck_logging_enable_category.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_logging_enable_category", category);
            }
            mh$.invokeExact(category);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_logging_disable_category {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_logging_disable_category");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_logging_disable_category(btck_LogCategory category)
     * }
     */
    public static FunctionDescriptor btck_logging_disable_category$descriptor() {
        return btck_logging_disable_category.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_logging_disable_category(btck_LogCategory category)
     * }
     */
    public static MethodHandle btck_logging_disable_category$handle() {
        return btck_logging_disable_category.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_logging_disable_category(btck_LogCategory category)
     * }
     */
    public static MemorySegment btck_logging_disable_category$address() {
        return btck_logging_disable_category.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_logging_disable_category(btck_LogCategory category)
     * }
     */
    public static void btck_logging_disable_category(byte category) {
        var mh$ = btck_logging_disable_category.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_logging_disable_category", category);
            }
            mh$.invokeExact(category);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_logging_connection_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_logging_connection_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_LoggingConnection *btck_logging_connection_create(btck_LogCallback log_callback, void *user_data, btck_DestroyCallback user_data_destroy_callback)
     * }
     */
    public static FunctionDescriptor btck_logging_connection_create$descriptor() {
        return btck_logging_connection_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_LoggingConnection *btck_logging_connection_create(btck_LogCallback log_callback, void *user_data, btck_DestroyCallback user_data_destroy_callback)
     * }
     */
    public static MethodHandle btck_logging_connection_create$handle() {
        return btck_logging_connection_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_LoggingConnection *btck_logging_connection_create(btck_LogCallback log_callback, void *user_data, btck_DestroyCallback user_data_destroy_callback)
     * }
     */
    public static MemorySegment btck_logging_connection_create$address() {
        return btck_logging_connection_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_LoggingConnection *btck_logging_connection_create(btck_LogCallback log_callback, void *user_data, btck_DestroyCallback user_data_destroy_callback)
     * }
     */
    public static MemorySegment btck_logging_connection_create(MemorySegment log_callback, MemorySegment user_data, MemorySegment user_data_destroy_callback) {
        var mh$ = btck_logging_connection_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_logging_connection_create", log_callback, user_data, user_data_destroy_callback);
            }
            return (MemorySegment)mh$.invokeExact(log_callback, user_data, user_data_destroy_callback);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_logging_connection_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_logging_connection_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_logging_connection_destroy(btck_LoggingConnection *logging_connection)
     * }
     */
    public static FunctionDescriptor btck_logging_connection_destroy$descriptor() {
        return btck_logging_connection_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_logging_connection_destroy(btck_LoggingConnection *logging_connection)
     * }
     */
    public static MethodHandle btck_logging_connection_destroy$handle() {
        return btck_logging_connection_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_logging_connection_destroy(btck_LoggingConnection *logging_connection)
     * }
     */
    public static MemorySegment btck_logging_connection_destroy$address() {
        return btck_logging_connection_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_logging_connection_destroy(btck_LoggingConnection *logging_connection)
     * }
     */
    public static void btck_logging_connection_destroy(MemorySegment logging_connection) {
        var mh$ = btck_logging_connection_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_logging_connection_destroy", logging_connection);
            }
            mh$.invokeExact(logging_connection);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chain_parameters_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chain_parameters_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_ChainParameters *btck_chain_parameters_create(const btck_ChainType chain_type)
     * }
     */
    public static FunctionDescriptor btck_chain_parameters_create$descriptor() {
        return btck_chain_parameters_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_ChainParameters *btck_chain_parameters_create(const btck_ChainType chain_type)
     * }
     */
    public static MethodHandle btck_chain_parameters_create$handle() {
        return btck_chain_parameters_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_ChainParameters *btck_chain_parameters_create(const btck_ChainType chain_type)
     * }
     */
    public static MemorySegment btck_chain_parameters_create$address() {
        return btck_chain_parameters_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_ChainParameters *btck_chain_parameters_create(const btck_ChainType chain_type)
     * }
     */
    public static MemorySegment btck_chain_parameters_create(byte chain_type) {
        var mh$ = btck_chain_parameters_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chain_parameters_create", chain_type);
            }
            return (MemorySegment)mh$.invokeExact(chain_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chain_parameters_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chain_parameters_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_ChainParameters *btck_chain_parameters_copy(const btck_ChainParameters *chain_parameters)
     * }
     */
    public static FunctionDescriptor btck_chain_parameters_copy$descriptor() {
        return btck_chain_parameters_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_ChainParameters *btck_chain_parameters_copy(const btck_ChainParameters *chain_parameters)
     * }
     */
    public static MethodHandle btck_chain_parameters_copy$handle() {
        return btck_chain_parameters_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_ChainParameters *btck_chain_parameters_copy(const btck_ChainParameters *chain_parameters)
     * }
     */
    public static MemorySegment btck_chain_parameters_copy$address() {
        return btck_chain_parameters_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_ChainParameters *btck_chain_parameters_copy(const btck_ChainParameters *chain_parameters)
     * }
     */
    public static MemorySegment btck_chain_parameters_copy(MemorySegment chain_parameters) {
        var mh$ = btck_chain_parameters_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chain_parameters_copy", chain_parameters);
            }
            return (MemorySegment)mh$.invokeExact(chain_parameters);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chain_parameters_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chain_parameters_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_chain_parameters_destroy(btck_ChainParameters *chain_parameters)
     * }
     */
    public static FunctionDescriptor btck_chain_parameters_destroy$descriptor() {
        return btck_chain_parameters_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_chain_parameters_destroy(btck_ChainParameters *chain_parameters)
     * }
     */
    public static MethodHandle btck_chain_parameters_destroy$handle() {
        return btck_chain_parameters_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_chain_parameters_destroy(btck_ChainParameters *chain_parameters)
     * }
     */
    public static MemorySegment btck_chain_parameters_destroy$address() {
        return btck_chain_parameters_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_chain_parameters_destroy(btck_ChainParameters *chain_parameters)
     * }
     */
    public static void btck_chain_parameters_destroy(MemorySegment chain_parameters) {
        var mh$ = btck_chain_parameters_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chain_parameters_destroy", chain_parameters);
            }
            mh$.invokeExact(chain_parameters);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * btck_ContextOptions *btck_context_options_create()
     * }
     */
    public static class btck_context_options_create {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                bitcoinkernel_h.C_POINTER        );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_options_create");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private btck_context_options_create(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * btck_ContextOptions *btck_context_options_create()
         * }
         */
        public static btck_context_options_create makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new btck_context_options_create(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public MemorySegment apply(Object... x0) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("btck_context_options_create", x0);
                }
                return (MemorySegment) spreader.invokeExact(x0);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class btck_context_options_set_chainparams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_options_set_chainparams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_context_options_set_chainparams(btck_ContextOptions *context_options, const btck_ChainParameters *chain_parameters)
     * }
     */
    public static FunctionDescriptor btck_context_options_set_chainparams$descriptor() {
        return btck_context_options_set_chainparams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_context_options_set_chainparams(btck_ContextOptions *context_options, const btck_ChainParameters *chain_parameters)
     * }
     */
    public static MethodHandle btck_context_options_set_chainparams$handle() {
        return btck_context_options_set_chainparams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_context_options_set_chainparams(btck_ContextOptions *context_options, const btck_ChainParameters *chain_parameters)
     * }
     */
    public static MemorySegment btck_context_options_set_chainparams$address() {
        return btck_context_options_set_chainparams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_context_options_set_chainparams(btck_ContextOptions *context_options, const btck_ChainParameters *chain_parameters)
     * }
     */
    public static void btck_context_options_set_chainparams(MemorySegment context_options, MemorySegment chain_parameters) {
        var mh$ = btck_context_options_set_chainparams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_context_options_set_chainparams", context_options, chain_parameters);
            }
            mh$.invokeExact(context_options, chain_parameters);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_context_options_set_notifications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER,
            btck_NotificationInterfaceCallbacks.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_options_set_notifications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_context_options_set_notifications(btck_ContextOptions *context_options, btck_NotificationInterfaceCallbacks notifications)
     * }
     */
    public static FunctionDescriptor btck_context_options_set_notifications$descriptor() {
        return btck_context_options_set_notifications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_context_options_set_notifications(btck_ContextOptions *context_options, btck_NotificationInterfaceCallbacks notifications)
     * }
     */
    public static MethodHandle btck_context_options_set_notifications$handle() {
        return btck_context_options_set_notifications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_context_options_set_notifications(btck_ContextOptions *context_options, btck_NotificationInterfaceCallbacks notifications)
     * }
     */
    public static MemorySegment btck_context_options_set_notifications$address() {
        return btck_context_options_set_notifications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_context_options_set_notifications(btck_ContextOptions *context_options, btck_NotificationInterfaceCallbacks notifications)
     * }
     */
    public static void btck_context_options_set_notifications(MemorySegment context_options, MemorySegment notifications) {
        var mh$ = btck_context_options_set_notifications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_context_options_set_notifications", context_options, notifications);
            }
            mh$.invokeExact(context_options, notifications);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_context_options_set_validation_interface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER,
            btck_ValidationInterfaceCallbacks.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_options_set_validation_interface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_context_options_set_validation_interface(btck_ContextOptions *context_options, btck_ValidationInterfaceCallbacks validation_interface_callbacks)
     * }
     */
    public static FunctionDescriptor btck_context_options_set_validation_interface$descriptor() {
        return btck_context_options_set_validation_interface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_context_options_set_validation_interface(btck_ContextOptions *context_options, btck_ValidationInterfaceCallbacks validation_interface_callbacks)
     * }
     */
    public static MethodHandle btck_context_options_set_validation_interface$handle() {
        return btck_context_options_set_validation_interface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_context_options_set_validation_interface(btck_ContextOptions *context_options, btck_ValidationInterfaceCallbacks validation_interface_callbacks)
     * }
     */
    public static MemorySegment btck_context_options_set_validation_interface$address() {
        return btck_context_options_set_validation_interface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_context_options_set_validation_interface(btck_ContextOptions *context_options, btck_ValidationInterfaceCallbacks validation_interface_callbacks)
     * }
     */
    public static void btck_context_options_set_validation_interface(MemorySegment context_options, MemorySegment validation_interface_callbacks) {
        var mh$ = btck_context_options_set_validation_interface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_context_options_set_validation_interface", context_options, validation_interface_callbacks);
            }
            mh$.invokeExact(context_options, validation_interface_callbacks);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_context_options_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_options_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_context_options_destroy(btck_ContextOptions *context_options)
     * }
     */
    public static FunctionDescriptor btck_context_options_destroy$descriptor() {
        return btck_context_options_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_context_options_destroy(btck_ContextOptions *context_options)
     * }
     */
    public static MethodHandle btck_context_options_destroy$handle() {
        return btck_context_options_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_context_options_destroy(btck_ContextOptions *context_options)
     * }
     */
    public static MemorySegment btck_context_options_destroy$address() {
        return btck_context_options_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_context_options_destroy(btck_ContextOptions *context_options)
     * }
     */
    public static void btck_context_options_destroy(MemorySegment context_options) {
        var mh$ = btck_context_options_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_context_options_destroy", context_options);
            }
            mh$.invokeExact(context_options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_context_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Context *btck_context_create(const btck_ContextOptions *context_options)
     * }
     */
    public static FunctionDescriptor btck_context_create$descriptor() {
        return btck_context_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Context *btck_context_create(const btck_ContextOptions *context_options)
     * }
     */
    public static MethodHandle btck_context_create$handle() {
        return btck_context_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Context *btck_context_create(const btck_ContextOptions *context_options)
     * }
     */
    public static MemorySegment btck_context_create$address() {
        return btck_context_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Context *btck_context_create(const btck_ContextOptions *context_options)
     * }
     */
    public static MemorySegment btck_context_create(MemorySegment context_options) {
        var mh$ = btck_context_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_context_create", context_options);
            }
            return (MemorySegment)mh$.invokeExact(context_options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_context_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Context *btck_context_copy(const btck_Context *context)
     * }
     */
    public static FunctionDescriptor btck_context_copy$descriptor() {
        return btck_context_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Context *btck_context_copy(const btck_Context *context)
     * }
     */
    public static MethodHandle btck_context_copy$handle() {
        return btck_context_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Context *btck_context_copy(const btck_Context *context)
     * }
     */
    public static MemorySegment btck_context_copy$address() {
        return btck_context_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Context *btck_context_copy(const btck_Context *context)
     * }
     */
    public static MemorySegment btck_context_copy(MemorySegment context) {
        var mh$ = btck_context_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_context_copy", context);
            }
            return (MemorySegment)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_context_interrupt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_interrupt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_context_interrupt(btck_Context *context)
     * }
     */
    public static FunctionDescriptor btck_context_interrupt$descriptor() {
        return btck_context_interrupt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_context_interrupt(btck_Context *context)
     * }
     */
    public static MethodHandle btck_context_interrupt$handle() {
        return btck_context_interrupt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_context_interrupt(btck_Context *context)
     * }
     */
    public static MemorySegment btck_context_interrupt$address() {
        return btck_context_interrupt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_context_interrupt(btck_Context *context)
     * }
     */
    public static int btck_context_interrupt(MemorySegment context) {
        var mh$ = btck_context_interrupt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_context_interrupt", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_context_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_context_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_context_destroy(btck_Context *context)
     * }
     */
    public static FunctionDescriptor btck_context_destroy$descriptor() {
        return btck_context_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_context_destroy(btck_Context *context)
     * }
     */
    public static MethodHandle btck_context_destroy$handle() {
        return btck_context_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_context_destroy(btck_Context *context)
     * }
     */
    public static MemorySegment btck_context_destroy$address() {
        return btck_context_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_context_destroy(btck_Context *context)
     * }
     */
    public static void btck_context_destroy(MemorySegment context) {
        var mh$ = btck_context_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_context_destroy", context);
            }
            mh$.invokeExact(context);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_tree_entry_get_previous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_tree_entry_get_previous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_block_tree_entry_get_previous(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static FunctionDescriptor btck_block_tree_entry_get_previous$descriptor() {
        return btck_block_tree_entry_get_previous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_block_tree_entry_get_previous(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MethodHandle btck_block_tree_entry_get_previous$handle() {
        return btck_block_tree_entry_get_previous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_block_tree_entry_get_previous(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_tree_entry_get_previous$address() {
        return btck_block_tree_entry_get_previous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_block_tree_entry_get_previous(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_tree_entry_get_previous(MemorySegment block_tree_entry) {
        var mh$ = btck_block_tree_entry_get_previous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_tree_entry_get_previous", block_tree_entry);
            }
            return (MemorySegment)mh$.invokeExact(block_tree_entry);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_tree_entry_get_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_tree_entry_get_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t btck_block_tree_entry_get_height(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static FunctionDescriptor btck_block_tree_entry_get_height$descriptor() {
        return btck_block_tree_entry_get_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t btck_block_tree_entry_get_height(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MethodHandle btck_block_tree_entry_get_height$handle() {
        return btck_block_tree_entry_get_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t btck_block_tree_entry_get_height(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_tree_entry_get_height$address() {
        return btck_block_tree_entry_get_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t btck_block_tree_entry_get_height(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static int btck_block_tree_entry_get_height(MemorySegment block_tree_entry) {
        var mh$ = btck_block_tree_entry_get_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_tree_entry_get_height", block_tree_entry);
            }
            return (int)mh$.invokeExact(block_tree_entry);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_tree_entry_get_block_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_tree_entry_get_block_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_BlockHash *btck_block_tree_entry_get_block_hash(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static FunctionDescriptor btck_block_tree_entry_get_block_hash$descriptor() {
        return btck_block_tree_entry_get_block_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_BlockHash *btck_block_tree_entry_get_block_hash(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MethodHandle btck_block_tree_entry_get_block_hash$handle() {
        return btck_block_tree_entry_get_block_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_BlockHash *btck_block_tree_entry_get_block_hash(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_tree_entry_get_block_hash$address() {
        return btck_block_tree_entry_get_block_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_BlockHash *btck_block_tree_entry_get_block_hash(const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_tree_entry_get_block_hash(MemorySegment block_tree_entry) {
        var mh$ = btck_block_tree_entry_get_block_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_tree_entry_get_block_hash", block_tree_entry);
            }
            return (MemorySegment)mh$.invokeExact(block_tree_entry);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_options_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_options_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_ChainstateManagerOptions *btck_chainstate_manager_options_create(const btck_Context *context, const char *data_directory, size_t data_directory_len, const char *blocks_directory, size_t blocks_directory_len)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_options_create$descriptor() {
        return btck_chainstate_manager_options_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_ChainstateManagerOptions *btck_chainstate_manager_options_create(const btck_Context *context, const char *data_directory, size_t data_directory_len, const char *blocks_directory, size_t blocks_directory_len)
     * }
     */
    public static MethodHandle btck_chainstate_manager_options_create$handle() {
        return btck_chainstate_manager_options_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_ChainstateManagerOptions *btck_chainstate_manager_options_create(const btck_Context *context, const char *data_directory, size_t data_directory_len, const char *blocks_directory, size_t blocks_directory_len)
     * }
     */
    public static MemorySegment btck_chainstate_manager_options_create$address() {
        return btck_chainstate_manager_options_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_ChainstateManagerOptions *btck_chainstate_manager_options_create(const btck_Context *context, const char *data_directory, size_t data_directory_len, const char *blocks_directory, size_t blocks_directory_len)
     * }
     */
    public static MemorySegment btck_chainstate_manager_options_create(MemorySegment context, MemorySegment data_directory, long data_directory_len, MemorySegment blocks_directory, long blocks_directory_len) {
        var mh$ = btck_chainstate_manager_options_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_options_create", context, data_directory, data_directory_len, blocks_directory, blocks_directory_len);
            }
            return (MemorySegment)mh$.invokeExact(context, data_directory, data_directory_len, blocks_directory, blocks_directory_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_options_set_worker_threads_num {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_options_set_worker_threads_num");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_set_worker_threads_num(btck_ChainstateManagerOptions *chainstate_manager_options, int worker_threads)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_options_set_worker_threads_num$descriptor() {
        return btck_chainstate_manager_options_set_worker_threads_num.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_set_worker_threads_num(btck_ChainstateManagerOptions *chainstate_manager_options, int worker_threads)
     * }
     */
    public static MethodHandle btck_chainstate_manager_options_set_worker_threads_num$handle() {
        return btck_chainstate_manager_options_set_worker_threads_num.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_set_worker_threads_num(btck_ChainstateManagerOptions *chainstate_manager_options, int worker_threads)
     * }
     */
    public static MemorySegment btck_chainstate_manager_options_set_worker_threads_num$address() {
        return btck_chainstate_manager_options_set_worker_threads_num.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_set_worker_threads_num(btck_ChainstateManagerOptions *chainstate_manager_options, int worker_threads)
     * }
     */
    public static void btck_chainstate_manager_options_set_worker_threads_num(MemorySegment chainstate_manager_options, int worker_threads) {
        var mh$ = btck_chainstate_manager_options_set_worker_threads_num.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_options_set_worker_threads_num", chainstate_manager_options, worker_threads);
            }
            mh$.invokeExact(chainstate_manager_options, worker_threads);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_options_set_wipe_dbs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_options_set_wipe_dbs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_options_set_wipe_dbs(btck_ChainstateManagerOptions *chainstate_manager_options, int wipe_block_tree_db, int wipe_chainstate_db)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_options_set_wipe_dbs$descriptor() {
        return btck_chainstate_manager_options_set_wipe_dbs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_options_set_wipe_dbs(btck_ChainstateManagerOptions *chainstate_manager_options, int wipe_block_tree_db, int wipe_chainstate_db)
     * }
     */
    public static MethodHandle btck_chainstate_manager_options_set_wipe_dbs$handle() {
        return btck_chainstate_manager_options_set_wipe_dbs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_options_set_wipe_dbs(btck_ChainstateManagerOptions *chainstate_manager_options, int wipe_block_tree_db, int wipe_chainstate_db)
     * }
     */
    public static MemorySegment btck_chainstate_manager_options_set_wipe_dbs$address() {
        return btck_chainstate_manager_options_set_wipe_dbs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_chainstate_manager_options_set_wipe_dbs(btck_ChainstateManagerOptions *chainstate_manager_options, int wipe_block_tree_db, int wipe_chainstate_db)
     * }
     */
    public static int btck_chainstate_manager_options_set_wipe_dbs(MemorySegment chainstate_manager_options, int wipe_block_tree_db, int wipe_chainstate_db) {
        var mh$ = btck_chainstate_manager_options_set_wipe_dbs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_options_set_wipe_dbs", chainstate_manager_options, wipe_block_tree_db, wipe_chainstate_db);
            }
            return (int)mh$.invokeExact(chainstate_manager_options, wipe_block_tree_db, wipe_chainstate_db);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_options_update_block_tree_db_in_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_options_update_block_tree_db_in_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_update_block_tree_db_in_memory(btck_ChainstateManagerOptions *chainstate_manager_options, int block_tree_db_in_memory)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_options_update_block_tree_db_in_memory$descriptor() {
        return btck_chainstate_manager_options_update_block_tree_db_in_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_update_block_tree_db_in_memory(btck_ChainstateManagerOptions *chainstate_manager_options, int block_tree_db_in_memory)
     * }
     */
    public static MethodHandle btck_chainstate_manager_options_update_block_tree_db_in_memory$handle() {
        return btck_chainstate_manager_options_update_block_tree_db_in_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_update_block_tree_db_in_memory(btck_ChainstateManagerOptions *chainstate_manager_options, int block_tree_db_in_memory)
     * }
     */
    public static MemorySegment btck_chainstate_manager_options_update_block_tree_db_in_memory$address() {
        return btck_chainstate_manager_options_update_block_tree_db_in_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_update_block_tree_db_in_memory(btck_ChainstateManagerOptions *chainstate_manager_options, int block_tree_db_in_memory)
     * }
     */
    public static void btck_chainstate_manager_options_update_block_tree_db_in_memory(MemorySegment chainstate_manager_options, int block_tree_db_in_memory) {
        var mh$ = btck_chainstate_manager_options_update_block_tree_db_in_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_options_update_block_tree_db_in_memory", chainstate_manager_options, block_tree_db_in_memory);
            }
            mh$.invokeExact(chainstate_manager_options, block_tree_db_in_memory);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_options_update_chainstate_db_in_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_options_update_chainstate_db_in_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_update_chainstate_db_in_memory(btck_ChainstateManagerOptions *chainstate_manager_options, int chainstate_db_in_memory)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_options_update_chainstate_db_in_memory$descriptor() {
        return btck_chainstate_manager_options_update_chainstate_db_in_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_update_chainstate_db_in_memory(btck_ChainstateManagerOptions *chainstate_manager_options, int chainstate_db_in_memory)
     * }
     */
    public static MethodHandle btck_chainstate_manager_options_update_chainstate_db_in_memory$handle() {
        return btck_chainstate_manager_options_update_chainstate_db_in_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_update_chainstate_db_in_memory(btck_ChainstateManagerOptions *chainstate_manager_options, int chainstate_db_in_memory)
     * }
     */
    public static MemorySegment btck_chainstate_manager_options_update_chainstate_db_in_memory$address() {
        return btck_chainstate_manager_options_update_chainstate_db_in_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_update_chainstate_db_in_memory(btck_ChainstateManagerOptions *chainstate_manager_options, int chainstate_db_in_memory)
     * }
     */
    public static void btck_chainstate_manager_options_update_chainstate_db_in_memory(MemorySegment chainstate_manager_options, int chainstate_db_in_memory) {
        var mh$ = btck_chainstate_manager_options_update_chainstate_db_in_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_options_update_chainstate_db_in_memory", chainstate_manager_options, chainstate_db_in_memory);
            }
            mh$.invokeExact(chainstate_manager_options, chainstate_db_in_memory);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_options_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_options_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_destroy(btck_ChainstateManagerOptions *chainstate_manager_options)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_options_destroy$descriptor() {
        return btck_chainstate_manager_options_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_destroy(btck_ChainstateManagerOptions *chainstate_manager_options)
     * }
     */
    public static MethodHandle btck_chainstate_manager_options_destroy$handle() {
        return btck_chainstate_manager_options_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_destroy(btck_ChainstateManagerOptions *chainstate_manager_options)
     * }
     */
    public static MemorySegment btck_chainstate_manager_options_destroy$address() {
        return btck_chainstate_manager_options_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_chainstate_manager_options_destroy(btck_ChainstateManagerOptions *chainstate_manager_options)
     * }
     */
    public static void btck_chainstate_manager_options_destroy(MemorySegment chainstate_manager_options) {
        var mh$ = btck_chainstate_manager_options_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_options_destroy", chainstate_manager_options);
            }
            mh$.invokeExact(chainstate_manager_options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_ChainstateManager *btck_chainstate_manager_create(const btck_ChainstateManagerOptions *chainstate_manager_options)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_create$descriptor() {
        return btck_chainstate_manager_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_ChainstateManager *btck_chainstate_manager_create(const btck_ChainstateManagerOptions *chainstate_manager_options)
     * }
     */
    public static MethodHandle btck_chainstate_manager_create$handle() {
        return btck_chainstate_manager_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_ChainstateManager *btck_chainstate_manager_create(const btck_ChainstateManagerOptions *chainstate_manager_options)
     * }
     */
    public static MemorySegment btck_chainstate_manager_create$address() {
        return btck_chainstate_manager_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_ChainstateManager *btck_chainstate_manager_create(const btck_ChainstateManagerOptions *chainstate_manager_options)
     * }
     */
    public static MemorySegment btck_chainstate_manager_create(MemorySegment chainstate_manager_options) {
        var mh$ = btck_chainstate_manager_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_create", chainstate_manager_options);
            }
            return (MemorySegment)mh$.invokeExact(chainstate_manager_options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_import_blocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_import_blocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_import_blocks(btck_ChainstateManager *chainstate_manager, const char **block_file_paths_data, size_t *block_file_paths_lens, size_t block_file_paths_data_len)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_import_blocks$descriptor() {
        return btck_chainstate_manager_import_blocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_import_blocks(btck_ChainstateManager *chainstate_manager, const char **block_file_paths_data, size_t *block_file_paths_lens, size_t block_file_paths_data_len)
     * }
     */
    public static MethodHandle btck_chainstate_manager_import_blocks$handle() {
        return btck_chainstate_manager_import_blocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_import_blocks(btck_ChainstateManager *chainstate_manager, const char **block_file_paths_data, size_t *block_file_paths_lens, size_t block_file_paths_data_len)
     * }
     */
    public static MemorySegment btck_chainstate_manager_import_blocks$address() {
        return btck_chainstate_manager_import_blocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_chainstate_manager_import_blocks(btck_ChainstateManager *chainstate_manager, const char **block_file_paths_data, size_t *block_file_paths_lens, size_t block_file_paths_data_len)
     * }
     */
    public static int btck_chainstate_manager_import_blocks(MemorySegment chainstate_manager, MemorySegment block_file_paths_data, MemorySegment block_file_paths_lens, long block_file_paths_data_len) {
        var mh$ = btck_chainstate_manager_import_blocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_import_blocks", chainstate_manager, block_file_paths_data, block_file_paths_lens, block_file_paths_data_len);
            }
            return (int)mh$.invokeExact(chainstate_manager, block_file_paths_data, block_file_paths_lens, block_file_paths_data_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_process_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_process_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_process_block(btck_ChainstateManager *chainstate_manager, const btck_Block *block, int *new_block)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_process_block$descriptor() {
        return btck_chainstate_manager_process_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_process_block(btck_ChainstateManager *chainstate_manager, const btck_Block *block, int *new_block)
     * }
     */
    public static MethodHandle btck_chainstate_manager_process_block$handle() {
        return btck_chainstate_manager_process_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_chainstate_manager_process_block(btck_ChainstateManager *chainstate_manager, const btck_Block *block, int *new_block)
     * }
     */
    public static MemorySegment btck_chainstate_manager_process_block$address() {
        return btck_chainstate_manager_process_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_chainstate_manager_process_block(btck_ChainstateManager *chainstate_manager, const btck_Block *block, int *new_block)
     * }
     */
    public static int btck_chainstate_manager_process_block(MemorySegment chainstate_manager, MemorySegment block, MemorySegment new_block) {
        var mh$ = btck_chainstate_manager_process_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_process_block", chainstate_manager, block, new_block);
            }
            return (int)mh$.invokeExact(chainstate_manager, block, new_block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_get_active_chain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_get_active_chain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_Chain *btck_chainstate_manager_get_active_chain(const btck_ChainstateManager *chainstate_manager)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_get_active_chain$descriptor() {
        return btck_chainstate_manager_get_active_chain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_Chain *btck_chainstate_manager_get_active_chain(const btck_ChainstateManager *chainstate_manager)
     * }
     */
    public static MethodHandle btck_chainstate_manager_get_active_chain$handle() {
        return btck_chainstate_manager_get_active_chain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_Chain *btck_chainstate_manager_get_active_chain(const btck_ChainstateManager *chainstate_manager)
     * }
     */
    public static MemorySegment btck_chainstate_manager_get_active_chain$address() {
        return btck_chainstate_manager_get_active_chain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_Chain *btck_chainstate_manager_get_active_chain(const btck_ChainstateManager *chainstate_manager)
     * }
     */
    public static MemorySegment btck_chainstate_manager_get_active_chain(MemorySegment chainstate_manager) {
        var mh$ = btck_chainstate_manager_get_active_chain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_get_active_chain", chainstate_manager);
            }
            return (MemorySegment)mh$.invokeExact(chainstate_manager);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_get_block_tree_entry_by_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_get_block_tree_entry_by_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_chainstate_manager_get_block_tree_entry_by_hash(const btck_ChainstateManager *chainstate_manager, const btck_BlockHash *block_hash)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_get_block_tree_entry_by_hash$descriptor() {
        return btck_chainstate_manager_get_block_tree_entry_by_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_chainstate_manager_get_block_tree_entry_by_hash(const btck_ChainstateManager *chainstate_manager, const btck_BlockHash *block_hash)
     * }
     */
    public static MethodHandle btck_chainstate_manager_get_block_tree_entry_by_hash$handle() {
        return btck_chainstate_manager_get_block_tree_entry_by_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_chainstate_manager_get_block_tree_entry_by_hash(const btck_ChainstateManager *chainstate_manager, const btck_BlockHash *block_hash)
     * }
     */
    public static MemorySegment btck_chainstate_manager_get_block_tree_entry_by_hash$address() {
        return btck_chainstate_manager_get_block_tree_entry_by_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_chainstate_manager_get_block_tree_entry_by_hash(const btck_ChainstateManager *chainstate_manager, const btck_BlockHash *block_hash)
     * }
     */
    public static MemorySegment btck_chainstate_manager_get_block_tree_entry_by_hash(MemorySegment chainstate_manager, MemorySegment block_hash) {
        var mh$ = btck_chainstate_manager_get_block_tree_entry_by_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_get_block_tree_entry_by_hash", chainstate_manager, block_hash);
            }
            return (MemorySegment)mh$.invokeExact(chainstate_manager, block_hash);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chainstate_manager_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chainstate_manager_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_destroy(btck_ChainstateManager *chainstate_manager)
     * }
     */
    public static FunctionDescriptor btck_chainstate_manager_destroy$descriptor() {
        return btck_chainstate_manager_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_destroy(btck_ChainstateManager *chainstate_manager)
     * }
     */
    public static MethodHandle btck_chainstate_manager_destroy$handle() {
        return btck_chainstate_manager_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_chainstate_manager_destroy(btck_ChainstateManager *chainstate_manager)
     * }
     */
    public static MemorySegment btck_chainstate_manager_destroy$address() {
        return btck_chainstate_manager_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_chainstate_manager_destroy(btck_ChainstateManager *chainstate_manager)
     * }
     */
    public static void btck_chainstate_manager_destroy(MemorySegment chainstate_manager) {
        var mh$ = btck_chainstate_manager_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chainstate_manager_destroy", chainstate_manager);
            }
            mh$.invokeExact(chainstate_manager);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Block *btck_block_read(const btck_ChainstateManager *chainstate_manager, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static FunctionDescriptor btck_block_read$descriptor() {
        return btck_block_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Block *btck_block_read(const btck_ChainstateManager *chainstate_manager, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MethodHandle btck_block_read$handle() {
        return btck_block_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Block *btck_block_read(const btck_ChainstateManager *chainstate_manager, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_read$address() {
        return btck_block_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Block *btck_block_read(const btck_ChainstateManager *chainstate_manager, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_read(MemorySegment chainstate_manager, MemorySegment block_tree_entry) {
        var mh$ = btck_block_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_read", chainstate_manager, block_tree_entry);
            }
            return (MemorySegment)mh$.invokeExact(chainstate_manager, block_tree_entry);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Block *btck_block_create(const void *raw_block, size_t raw_block_len)
     * }
     */
    public static FunctionDescriptor btck_block_create$descriptor() {
        return btck_block_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Block *btck_block_create(const void *raw_block, size_t raw_block_len)
     * }
     */
    public static MethodHandle btck_block_create$handle() {
        return btck_block_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Block *btck_block_create(const void *raw_block, size_t raw_block_len)
     * }
     */
    public static MemorySegment btck_block_create$address() {
        return btck_block_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Block *btck_block_create(const void *raw_block, size_t raw_block_len)
     * }
     */
    public static MemorySegment btck_block_create(MemorySegment raw_block, long raw_block_len) {
        var mh$ = btck_block_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_create", raw_block, raw_block_len);
            }
            return (MemorySegment)mh$.invokeExact(raw_block, raw_block_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Block *btck_block_copy(const btck_Block *block)
     * }
     */
    public static FunctionDescriptor btck_block_copy$descriptor() {
        return btck_block_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Block *btck_block_copy(const btck_Block *block)
     * }
     */
    public static MethodHandle btck_block_copy$handle() {
        return btck_block_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Block *btck_block_copy(const btck_Block *block)
     * }
     */
    public static MemorySegment btck_block_copy$address() {
        return btck_block_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Block *btck_block_copy(const btck_Block *block)
     * }
     */
    public static MemorySegment btck_block_copy(MemorySegment block) {
        var mh$ = btck_block_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_copy", block);
            }
            return (MemorySegment)mh$.invokeExact(block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_count_transactions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_LONG,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_count_transactions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t btck_block_count_transactions(const btck_Block *block)
     * }
     */
    public static FunctionDescriptor btck_block_count_transactions$descriptor() {
        return btck_block_count_transactions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t btck_block_count_transactions(const btck_Block *block)
     * }
     */
    public static MethodHandle btck_block_count_transactions$handle() {
        return btck_block_count_transactions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t btck_block_count_transactions(const btck_Block *block)
     * }
     */
    public static MemorySegment btck_block_count_transactions$address() {
        return btck_block_count_transactions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t btck_block_count_transactions(const btck_Block *block)
     * }
     */
    public static long btck_block_count_transactions(MemorySegment block) {
        var mh$ = btck_block_count_transactions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_count_transactions", block);
            }
            return (long)mh$.invokeExact(block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_get_transaction_at {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_get_transaction_at");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_Transaction *btck_block_get_transaction_at(const btck_Block *block, size_t transaction_index)
     * }
     */
    public static FunctionDescriptor btck_block_get_transaction_at$descriptor() {
        return btck_block_get_transaction_at.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_Transaction *btck_block_get_transaction_at(const btck_Block *block, size_t transaction_index)
     * }
     */
    public static MethodHandle btck_block_get_transaction_at$handle() {
        return btck_block_get_transaction_at.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_Transaction *btck_block_get_transaction_at(const btck_Block *block, size_t transaction_index)
     * }
     */
    public static MemorySegment btck_block_get_transaction_at$address() {
        return btck_block_get_transaction_at.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_Transaction *btck_block_get_transaction_at(const btck_Block *block, size_t transaction_index)
     * }
     */
    public static MemorySegment btck_block_get_transaction_at(MemorySegment block, long transaction_index) {
        var mh$ = btck_block_get_transaction_at.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_get_transaction_at", block, transaction_index);
            }
            return (MemorySegment)mh$.invokeExact(block, transaction_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_get_hash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_get_hash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_get_hash(const btck_Block *block)
     * }
     */
    public static FunctionDescriptor btck_block_get_hash$descriptor() {
        return btck_block_get_hash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_get_hash(const btck_Block *block)
     * }
     */
    public static MethodHandle btck_block_get_hash$handle() {
        return btck_block_get_hash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_get_hash(const btck_Block *block)
     * }
     */
    public static MemorySegment btck_block_get_hash$address() {
        return btck_block_get_hash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_get_hash(const btck_Block *block)
     * }
     */
    public static MemorySegment btck_block_get_hash(MemorySegment block) {
        var mh$ = btck_block_get_hash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_get_hash", block);
            }
            return (MemorySegment)mh$.invokeExact(block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_to_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_to_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_block_to_bytes(const btck_Block *block, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static FunctionDescriptor btck_block_to_bytes$descriptor() {
        return btck_block_to_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_block_to_bytes(const btck_Block *block, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static MethodHandle btck_block_to_bytes$handle() {
        return btck_block_to_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_block_to_bytes(const btck_Block *block, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static MemorySegment btck_block_to_bytes$address() {
        return btck_block_to_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_block_to_bytes(const btck_Block *block, btck_WriteBytes writer, void *user_data)
     * }
     */
    public static int btck_block_to_bytes(MemorySegment block, MemorySegment writer, MemorySegment user_data) {
        var mh$ = btck_block_to_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_to_bytes", block, writer, user_data);
            }
            return (int)mh$.invokeExact(block, writer, user_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_block_destroy(btck_Block *block)
     * }
     */
    public static FunctionDescriptor btck_block_destroy$descriptor() {
        return btck_block_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_block_destroy(btck_Block *block)
     * }
     */
    public static MethodHandle btck_block_destroy$handle() {
        return btck_block_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_block_destroy(btck_Block *block)
     * }
     */
    public static MemorySegment btck_block_destroy$address() {
        return btck_block_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_block_destroy(btck_Block *block)
     * }
     */
    public static void btck_block_destroy(MemorySegment block) {
        var mh$ = btck_block_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_destroy", block);
            }
            mh$.invokeExact(block);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_validation_state_get_validation_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_CHAR,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_validation_state_get_validation_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_ValidationMode btck_block_validation_state_get_validation_mode(const btck_BlockValidationState *block_validation_state)
     * }
     */
    public static FunctionDescriptor btck_block_validation_state_get_validation_mode$descriptor() {
        return btck_block_validation_state_get_validation_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_ValidationMode btck_block_validation_state_get_validation_mode(const btck_BlockValidationState *block_validation_state)
     * }
     */
    public static MethodHandle btck_block_validation_state_get_validation_mode$handle() {
        return btck_block_validation_state_get_validation_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_ValidationMode btck_block_validation_state_get_validation_mode(const btck_BlockValidationState *block_validation_state)
     * }
     */
    public static MemorySegment btck_block_validation_state_get_validation_mode$address() {
        return btck_block_validation_state_get_validation_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_ValidationMode btck_block_validation_state_get_validation_mode(const btck_BlockValidationState *block_validation_state)
     * }
     */
    public static byte btck_block_validation_state_get_validation_mode(MemorySegment block_validation_state) {
        var mh$ = btck_block_validation_state_get_validation_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_validation_state_get_validation_mode", block_validation_state);
            }
            return (byte)mh$.invokeExact(block_validation_state);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_validation_state_get_block_validation_result {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_validation_state_get_block_validation_result");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_BlockValidationResult btck_block_validation_state_get_block_validation_result(const btck_BlockValidationState *block_validation_state)
     * }
     */
    public static FunctionDescriptor btck_block_validation_state_get_block_validation_result$descriptor() {
        return btck_block_validation_state_get_block_validation_result.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_BlockValidationResult btck_block_validation_state_get_block_validation_result(const btck_BlockValidationState *block_validation_state)
     * }
     */
    public static MethodHandle btck_block_validation_state_get_block_validation_result$handle() {
        return btck_block_validation_state_get_block_validation_result.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_BlockValidationResult btck_block_validation_state_get_block_validation_result(const btck_BlockValidationState *block_validation_state)
     * }
     */
    public static MemorySegment btck_block_validation_state_get_block_validation_result$address() {
        return btck_block_validation_state_get_block_validation_result.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_BlockValidationResult btck_block_validation_state_get_block_validation_result(const btck_BlockValidationState *block_validation_state)
     * }
     */
    public static int btck_block_validation_state_get_block_validation_result(MemorySegment block_validation_state) {
        var mh$ = btck_block_validation_state_get_block_validation_result.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_validation_state_get_block_validation_result", block_validation_state);
            }
            return (int)mh$.invokeExact(block_validation_state);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chain_get_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chain_get_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t btck_chain_get_height(const btck_Chain *chain)
     * }
     */
    public static FunctionDescriptor btck_chain_get_height$descriptor() {
        return btck_chain_get_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t btck_chain_get_height(const btck_Chain *chain)
     * }
     */
    public static MethodHandle btck_chain_get_height$handle() {
        return btck_chain_get_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t btck_chain_get_height(const btck_Chain *chain)
     * }
     */
    public static MemorySegment btck_chain_get_height$address() {
        return btck_chain_get_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t btck_chain_get_height(const btck_Chain *chain)
     * }
     */
    public static int btck_chain_get_height(MemorySegment chain) {
        var mh$ = btck_chain_get_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chain_get_height", chain);
            }
            return (int)mh$.invokeExact(chain);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chain_get_by_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chain_get_by_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_chain_get_by_height(const btck_Chain *chain, int block_height)
     * }
     */
    public static FunctionDescriptor btck_chain_get_by_height$descriptor() {
        return btck_chain_get_by_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_chain_get_by_height(const btck_Chain *chain, int block_height)
     * }
     */
    public static MethodHandle btck_chain_get_by_height$handle() {
        return btck_chain_get_by_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_chain_get_by_height(const btck_Chain *chain, int block_height)
     * }
     */
    public static MemorySegment btck_chain_get_by_height$address() {
        return btck_chain_get_by_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_BlockTreeEntry *btck_chain_get_by_height(const btck_Chain *chain, int block_height)
     * }
     */
    public static MemorySegment btck_chain_get_by_height(MemorySegment chain, int block_height) {
        var mh$ = btck_chain_get_by_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chain_get_by_height", chain, block_height);
            }
            return (MemorySegment)mh$.invokeExact(chain, block_height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_chain_contains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_chain_contains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_chain_contains(const btck_Chain *chain, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static FunctionDescriptor btck_chain_contains$descriptor() {
        return btck_chain_contains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_chain_contains(const btck_Chain *chain, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MethodHandle btck_chain_contains$handle() {
        return btck_chain_contains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_chain_contains(const btck_Chain *chain, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_chain_contains$address() {
        return btck_chain_contains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_chain_contains(const btck_Chain *chain, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static int btck_chain_contains(MemorySegment chain, MemorySegment block_tree_entry) {
        var mh$ = btck_chain_contains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_chain_contains", chain, block_tree_entry);
            }
            return (int)mh$.invokeExact(chain, block_tree_entry);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_spent_outputs_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_spent_outputs_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_BlockSpentOutputs *btck_block_spent_outputs_read(const btck_ChainstateManager *chainstate_manager, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static FunctionDescriptor btck_block_spent_outputs_read$descriptor() {
        return btck_block_spent_outputs_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_BlockSpentOutputs *btck_block_spent_outputs_read(const btck_ChainstateManager *chainstate_manager, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MethodHandle btck_block_spent_outputs_read$handle() {
        return btck_block_spent_outputs_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_BlockSpentOutputs *btck_block_spent_outputs_read(const btck_ChainstateManager *chainstate_manager, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_spent_outputs_read$address() {
        return btck_block_spent_outputs_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_BlockSpentOutputs *btck_block_spent_outputs_read(const btck_ChainstateManager *chainstate_manager, const btck_BlockTreeEntry *block_tree_entry)
     * }
     */
    public static MemorySegment btck_block_spent_outputs_read(MemorySegment chainstate_manager, MemorySegment block_tree_entry) {
        var mh$ = btck_block_spent_outputs_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_spent_outputs_read", chainstate_manager, block_tree_entry);
            }
            return (MemorySegment)mh$.invokeExact(chainstate_manager, block_tree_entry);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_spent_outputs_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_spent_outputs_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_BlockSpentOutputs *btck_block_spent_outputs_copy(const btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static FunctionDescriptor btck_block_spent_outputs_copy$descriptor() {
        return btck_block_spent_outputs_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_BlockSpentOutputs *btck_block_spent_outputs_copy(const btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static MethodHandle btck_block_spent_outputs_copy$handle() {
        return btck_block_spent_outputs_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_BlockSpentOutputs *btck_block_spent_outputs_copy(const btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static MemorySegment btck_block_spent_outputs_copy$address() {
        return btck_block_spent_outputs_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_BlockSpentOutputs *btck_block_spent_outputs_copy(const btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static MemorySegment btck_block_spent_outputs_copy(MemorySegment block_spent_outputs) {
        var mh$ = btck_block_spent_outputs_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_spent_outputs_copy", block_spent_outputs);
            }
            return (MemorySegment)mh$.invokeExact(block_spent_outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_spent_outputs_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_LONG,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_spent_outputs_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t btck_block_spent_outputs_count(const btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static FunctionDescriptor btck_block_spent_outputs_count$descriptor() {
        return btck_block_spent_outputs_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t btck_block_spent_outputs_count(const btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static MethodHandle btck_block_spent_outputs_count$handle() {
        return btck_block_spent_outputs_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t btck_block_spent_outputs_count(const btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static MemorySegment btck_block_spent_outputs_count$address() {
        return btck_block_spent_outputs_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t btck_block_spent_outputs_count(const btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static long btck_block_spent_outputs_count(MemorySegment block_spent_outputs) {
        var mh$ = btck_block_spent_outputs_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_spent_outputs_count", block_spent_outputs);
            }
            return (long)mh$.invokeExact(block_spent_outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_spent_outputs_get_transaction_spent_outputs_at {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_spent_outputs_get_transaction_spent_outputs_at");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_TransactionSpentOutputs *btck_block_spent_outputs_get_transaction_spent_outputs_at(const btck_BlockSpentOutputs *block_spent_outputs, size_t transaction_spent_outputs_index)
     * }
     */
    public static FunctionDescriptor btck_block_spent_outputs_get_transaction_spent_outputs_at$descriptor() {
        return btck_block_spent_outputs_get_transaction_spent_outputs_at.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_TransactionSpentOutputs *btck_block_spent_outputs_get_transaction_spent_outputs_at(const btck_BlockSpentOutputs *block_spent_outputs, size_t transaction_spent_outputs_index)
     * }
     */
    public static MethodHandle btck_block_spent_outputs_get_transaction_spent_outputs_at$handle() {
        return btck_block_spent_outputs_get_transaction_spent_outputs_at.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_TransactionSpentOutputs *btck_block_spent_outputs_get_transaction_spent_outputs_at(const btck_BlockSpentOutputs *block_spent_outputs, size_t transaction_spent_outputs_index)
     * }
     */
    public static MemorySegment btck_block_spent_outputs_get_transaction_spent_outputs_at$address() {
        return btck_block_spent_outputs_get_transaction_spent_outputs_at.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_TransactionSpentOutputs *btck_block_spent_outputs_get_transaction_spent_outputs_at(const btck_BlockSpentOutputs *block_spent_outputs, size_t transaction_spent_outputs_index)
     * }
     */
    public static MemorySegment btck_block_spent_outputs_get_transaction_spent_outputs_at(MemorySegment block_spent_outputs, long transaction_spent_outputs_index) {
        var mh$ = btck_block_spent_outputs_get_transaction_spent_outputs_at.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_spent_outputs_get_transaction_spent_outputs_at", block_spent_outputs, transaction_spent_outputs_index);
            }
            return (MemorySegment)mh$.invokeExact(block_spent_outputs, transaction_spent_outputs_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_spent_outputs_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_spent_outputs_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_block_spent_outputs_destroy(btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static FunctionDescriptor btck_block_spent_outputs_destroy$descriptor() {
        return btck_block_spent_outputs_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_block_spent_outputs_destroy(btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static MethodHandle btck_block_spent_outputs_destroy$handle() {
        return btck_block_spent_outputs_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_block_spent_outputs_destroy(btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static MemorySegment btck_block_spent_outputs_destroy$address() {
        return btck_block_spent_outputs_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_block_spent_outputs_destroy(btck_BlockSpentOutputs *block_spent_outputs)
     * }
     */
    public static void btck_block_spent_outputs_destroy(MemorySegment block_spent_outputs) {
        var mh$ = btck_block_spent_outputs_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_spent_outputs_destroy", block_spent_outputs);
            }
            mh$.invokeExact(block_spent_outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_spent_outputs_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_spent_outputs_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_TransactionSpentOutputs *btck_transaction_spent_outputs_copy(const btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static FunctionDescriptor btck_transaction_spent_outputs_copy$descriptor() {
        return btck_transaction_spent_outputs_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_TransactionSpentOutputs *btck_transaction_spent_outputs_copy(const btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static MethodHandle btck_transaction_spent_outputs_copy$handle() {
        return btck_transaction_spent_outputs_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_TransactionSpentOutputs *btck_transaction_spent_outputs_copy(const btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static MemorySegment btck_transaction_spent_outputs_copy$address() {
        return btck_transaction_spent_outputs_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_TransactionSpentOutputs *btck_transaction_spent_outputs_copy(const btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static MemorySegment btck_transaction_spent_outputs_copy(MemorySegment transaction_spent_outputs) {
        var mh$ = btck_transaction_spent_outputs_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_spent_outputs_copy", transaction_spent_outputs);
            }
            return (MemorySegment)mh$.invokeExact(transaction_spent_outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_spent_outputs_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_LONG,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_spent_outputs_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t btck_transaction_spent_outputs_count(const btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static FunctionDescriptor btck_transaction_spent_outputs_count$descriptor() {
        return btck_transaction_spent_outputs_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t btck_transaction_spent_outputs_count(const btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static MethodHandle btck_transaction_spent_outputs_count$handle() {
        return btck_transaction_spent_outputs_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t btck_transaction_spent_outputs_count(const btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static MemorySegment btck_transaction_spent_outputs_count$address() {
        return btck_transaction_spent_outputs_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t btck_transaction_spent_outputs_count(const btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static long btck_transaction_spent_outputs_count(MemorySegment transaction_spent_outputs) {
        var mh$ = btck_transaction_spent_outputs_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_spent_outputs_count", transaction_spent_outputs);
            }
            return (long)mh$.invokeExact(transaction_spent_outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_spent_outputs_get_coin_at {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_spent_outputs_get_coin_at");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_Coin *btck_transaction_spent_outputs_get_coin_at(const btck_TransactionSpentOutputs *transaction_spent_outputs, size_t coin_index)
     * }
     */
    public static FunctionDescriptor btck_transaction_spent_outputs_get_coin_at$descriptor() {
        return btck_transaction_spent_outputs_get_coin_at.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_Coin *btck_transaction_spent_outputs_get_coin_at(const btck_TransactionSpentOutputs *transaction_spent_outputs, size_t coin_index)
     * }
     */
    public static MethodHandle btck_transaction_spent_outputs_get_coin_at$handle() {
        return btck_transaction_spent_outputs_get_coin_at.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_Coin *btck_transaction_spent_outputs_get_coin_at(const btck_TransactionSpentOutputs *transaction_spent_outputs, size_t coin_index)
     * }
     */
    public static MemorySegment btck_transaction_spent_outputs_get_coin_at$address() {
        return btck_transaction_spent_outputs_get_coin_at.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_Coin *btck_transaction_spent_outputs_get_coin_at(const btck_TransactionSpentOutputs *transaction_spent_outputs, size_t coin_index)
     * }
     */
    public static MemorySegment btck_transaction_spent_outputs_get_coin_at(MemorySegment transaction_spent_outputs, long coin_index) {
        var mh$ = btck_transaction_spent_outputs_get_coin_at.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_spent_outputs_get_coin_at", transaction_spent_outputs, coin_index);
            }
            return (MemorySegment)mh$.invokeExact(transaction_spent_outputs, coin_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_spent_outputs_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_spent_outputs_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_transaction_spent_outputs_destroy(btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static FunctionDescriptor btck_transaction_spent_outputs_destroy$descriptor() {
        return btck_transaction_spent_outputs_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_transaction_spent_outputs_destroy(btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static MethodHandle btck_transaction_spent_outputs_destroy$handle() {
        return btck_transaction_spent_outputs_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_transaction_spent_outputs_destroy(btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static MemorySegment btck_transaction_spent_outputs_destroy$address() {
        return btck_transaction_spent_outputs_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_transaction_spent_outputs_destroy(btck_TransactionSpentOutputs *transaction_spent_outputs)
     * }
     */
    public static void btck_transaction_spent_outputs_destroy(MemorySegment transaction_spent_outputs) {
        var mh$ = btck_transaction_spent_outputs_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_spent_outputs_destroy", transaction_spent_outputs);
            }
            mh$.invokeExact(transaction_spent_outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_input_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_input_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_TransactionInput *btck_transaction_input_copy(const btck_TransactionInput *transaction_input)
     * }
     */
    public static FunctionDescriptor btck_transaction_input_copy$descriptor() {
        return btck_transaction_input_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_TransactionInput *btck_transaction_input_copy(const btck_TransactionInput *transaction_input)
     * }
     */
    public static MethodHandle btck_transaction_input_copy$handle() {
        return btck_transaction_input_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_TransactionInput *btck_transaction_input_copy(const btck_TransactionInput *transaction_input)
     * }
     */
    public static MemorySegment btck_transaction_input_copy$address() {
        return btck_transaction_input_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_TransactionInput *btck_transaction_input_copy(const btck_TransactionInput *transaction_input)
     * }
     */
    public static MemorySegment btck_transaction_input_copy(MemorySegment transaction_input) {
        var mh$ = btck_transaction_input_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_input_copy", transaction_input);
            }
            return (MemorySegment)mh$.invokeExact(transaction_input);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_input_get_out_point {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_input_get_out_point");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_TransactionOutPoint *btck_transaction_input_get_out_point(const btck_TransactionInput *transaction_input)
     * }
     */
    public static FunctionDescriptor btck_transaction_input_get_out_point$descriptor() {
        return btck_transaction_input_get_out_point.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_TransactionOutPoint *btck_transaction_input_get_out_point(const btck_TransactionInput *transaction_input)
     * }
     */
    public static MethodHandle btck_transaction_input_get_out_point$handle() {
        return btck_transaction_input_get_out_point.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_TransactionOutPoint *btck_transaction_input_get_out_point(const btck_TransactionInput *transaction_input)
     * }
     */
    public static MemorySegment btck_transaction_input_get_out_point$address() {
        return btck_transaction_input_get_out_point.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_TransactionOutPoint *btck_transaction_input_get_out_point(const btck_TransactionInput *transaction_input)
     * }
     */
    public static MemorySegment btck_transaction_input_get_out_point(MemorySegment transaction_input) {
        var mh$ = btck_transaction_input_get_out_point.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_input_get_out_point", transaction_input);
            }
            return (MemorySegment)mh$.invokeExact(transaction_input);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_input_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_input_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_transaction_input_destroy(btck_TransactionInput *transaction_input)
     * }
     */
    public static FunctionDescriptor btck_transaction_input_destroy$descriptor() {
        return btck_transaction_input_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_transaction_input_destroy(btck_TransactionInput *transaction_input)
     * }
     */
    public static MethodHandle btck_transaction_input_destroy$handle() {
        return btck_transaction_input_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_transaction_input_destroy(btck_TransactionInput *transaction_input)
     * }
     */
    public static MemorySegment btck_transaction_input_destroy$address() {
        return btck_transaction_input_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_transaction_input_destroy(btck_TransactionInput *transaction_input)
     * }
     */
    public static void btck_transaction_input_destroy(MemorySegment transaction_input) {
        var mh$ = btck_transaction_input_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_input_destroy", transaction_input);
            }
            mh$.invokeExact(transaction_input);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_out_point_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_out_point_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_TransactionOutPoint *btck_transaction_out_point_copy(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static FunctionDescriptor btck_transaction_out_point_copy$descriptor() {
        return btck_transaction_out_point_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_TransactionOutPoint *btck_transaction_out_point_copy(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MethodHandle btck_transaction_out_point_copy$handle() {
        return btck_transaction_out_point_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_TransactionOutPoint *btck_transaction_out_point_copy(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MemorySegment btck_transaction_out_point_copy$address() {
        return btck_transaction_out_point_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_TransactionOutPoint *btck_transaction_out_point_copy(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MemorySegment btck_transaction_out_point_copy(MemorySegment transaction_out_point) {
        var mh$ = btck_transaction_out_point_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_out_point_copy", transaction_out_point);
            }
            return (MemorySegment)mh$.invokeExact(transaction_out_point);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_out_point_get_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_out_point_get_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t btck_transaction_out_point_get_index(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static FunctionDescriptor btck_transaction_out_point_get_index$descriptor() {
        return btck_transaction_out_point_get_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t btck_transaction_out_point_get_index(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MethodHandle btck_transaction_out_point_get_index$handle() {
        return btck_transaction_out_point_get_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t btck_transaction_out_point_get_index(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MemorySegment btck_transaction_out_point_get_index$address() {
        return btck_transaction_out_point_get_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t btck_transaction_out_point_get_index(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static int btck_transaction_out_point_get_index(MemorySegment transaction_out_point) {
        var mh$ = btck_transaction_out_point_get_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_out_point_get_index", transaction_out_point);
            }
            return (int)mh$.invokeExact(transaction_out_point);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_out_point_get_txid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_out_point_get_txid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_Txid *btck_transaction_out_point_get_txid(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static FunctionDescriptor btck_transaction_out_point_get_txid$descriptor() {
        return btck_transaction_out_point_get_txid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_Txid *btck_transaction_out_point_get_txid(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MethodHandle btck_transaction_out_point_get_txid$handle() {
        return btck_transaction_out_point_get_txid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_Txid *btck_transaction_out_point_get_txid(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MemorySegment btck_transaction_out_point_get_txid$address() {
        return btck_transaction_out_point_get_txid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_Txid *btck_transaction_out_point_get_txid(const btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MemorySegment btck_transaction_out_point_get_txid(MemorySegment transaction_out_point) {
        var mh$ = btck_transaction_out_point_get_txid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_out_point_get_txid", transaction_out_point);
            }
            return (MemorySegment)mh$.invokeExact(transaction_out_point);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_transaction_out_point_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_transaction_out_point_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_transaction_out_point_destroy(btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static FunctionDescriptor btck_transaction_out_point_destroy$descriptor() {
        return btck_transaction_out_point_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_transaction_out_point_destroy(btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MethodHandle btck_transaction_out_point_destroy$handle() {
        return btck_transaction_out_point_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_transaction_out_point_destroy(btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static MemorySegment btck_transaction_out_point_destroy$address() {
        return btck_transaction_out_point_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_transaction_out_point_destroy(btck_TransactionOutPoint *transaction_out_point)
     * }
     */
    public static void btck_transaction_out_point_destroy(MemorySegment transaction_out_point) {
        var mh$ = btck_transaction_out_point_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_transaction_out_point_destroy", transaction_out_point);
            }
            mh$.invokeExact(transaction_out_point);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_txid_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_txid_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Txid *btck_txid_copy(const btck_Txid *txid)
     * }
     */
    public static FunctionDescriptor btck_txid_copy$descriptor() {
        return btck_txid_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Txid *btck_txid_copy(const btck_Txid *txid)
     * }
     */
    public static MethodHandle btck_txid_copy$handle() {
        return btck_txid_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Txid *btck_txid_copy(const btck_Txid *txid)
     * }
     */
    public static MemorySegment btck_txid_copy$address() {
        return btck_txid_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Txid *btck_txid_copy(const btck_Txid *txid)
     * }
     */
    public static MemorySegment btck_txid_copy(MemorySegment txid) {
        var mh$ = btck_txid_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_txid_copy", txid);
            }
            return (MemorySegment)mh$.invokeExact(txid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_txid_equals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_txid_equals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_txid_equals(const btck_Txid *txid1, const btck_Txid *txid2)
     * }
     */
    public static FunctionDescriptor btck_txid_equals$descriptor() {
        return btck_txid_equals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_txid_equals(const btck_Txid *txid1, const btck_Txid *txid2)
     * }
     */
    public static MethodHandle btck_txid_equals$handle() {
        return btck_txid_equals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_txid_equals(const btck_Txid *txid1, const btck_Txid *txid2)
     * }
     */
    public static MemorySegment btck_txid_equals$address() {
        return btck_txid_equals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_txid_equals(const btck_Txid *txid1, const btck_Txid *txid2)
     * }
     */
    public static int btck_txid_equals(MemorySegment txid1, MemorySegment txid2) {
        var mh$ = btck_txid_equals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_txid_equals", txid1, txid2);
            }
            return (int)mh$.invokeExact(txid1, txid2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_txid_to_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_txid_to_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_txid_to_bytes(const btck_Txid *txid, unsigned char output[32])
     * }
     */
    public static FunctionDescriptor btck_txid_to_bytes$descriptor() {
        return btck_txid_to_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_txid_to_bytes(const btck_Txid *txid, unsigned char output[32])
     * }
     */
    public static MethodHandle btck_txid_to_bytes$handle() {
        return btck_txid_to_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_txid_to_bytes(const btck_Txid *txid, unsigned char output[32])
     * }
     */
    public static MemorySegment btck_txid_to_bytes$address() {
        return btck_txid_to_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_txid_to_bytes(const btck_Txid *txid, unsigned char output[32])
     * }
     */
    public static void btck_txid_to_bytes(MemorySegment txid, MemorySegment output) {
        var mh$ = btck_txid_to_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_txid_to_bytes", txid, output);
            }
            mh$.invokeExact(txid, output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_txid_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_txid_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_txid_destroy(btck_Txid *txid)
     * }
     */
    public static FunctionDescriptor btck_txid_destroy$descriptor() {
        return btck_txid_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_txid_destroy(btck_Txid *txid)
     * }
     */
    public static MethodHandle btck_txid_destroy$handle() {
        return btck_txid_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_txid_destroy(btck_Txid *txid)
     * }
     */
    public static MemorySegment btck_txid_destroy$address() {
        return btck_txid_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_txid_destroy(btck_Txid *txid)
     * }
     */
    public static void btck_txid_destroy(MemorySegment txid) {
        var mh$ = btck_txid_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_txid_destroy", txid);
            }
            mh$.invokeExact(txid);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_coin_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_coin_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_Coin *btck_coin_copy(const btck_Coin *coin)
     * }
     */
    public static FunctionDescriptor btck_coin_copy$descriptor() {
        return btck_coin_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_Coin *btck_coin_copy(const btck_Coin *coin)
     * }
     */
    public static MethodHandle btck_coin_copy$handle() {
        return btck_coin_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_Coin *btck_coin_copy(const btck_Coin *coin)
     * }
     */
    public static MemorySegment btck_coin_copy$address() {
        return btck_coin_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_Coin *btck_coin_copy(const btck_Coin *coin)
     * }
     */
    public static MemorySegment btck_coin_copy(MemorySegment coin) {
        var mh$ = btck_coin_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_coin_copy", coin);
            }
            return (MemorySegment)mh$.invokeExact(coin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_coin_confirmation_height {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_coin_confirmation_height");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t btck_coin_confirmation_height(const btck_Coin *coin)
     * }
     */
    public static FunctionDescriptor btck_coin_confirmation_height$descriptor() {
        return btck_coin_confirmation_height.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t btck_coin_confirmation_height(const btck_Coin *coin)
     * }
     */
    public static MethodHandle btck_coin_confirmation_height$handle() {
        return btck_coin_confirmation_height.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t btck_coin_confirmation_height(const btck_Coin *coin)
     * }
     */
    public static MemorySegment btck_coin_confirmation_height$address() {
        return btck_coin_confirmation_height.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t btck_coin_confirmation_height(const btck_Coin *coin)
     * }
     */
    public static int btck_coin_confirmation_height(MemorySegment coin) {
        var mh$ = btck_coin_confirmation_height.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_coin_confirmation_height", coin);
            }
            return (int)mh$.invokeExact(coin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_coin_is_coinbase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_coin_is_coinbase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_coin_is_coinbase(const btck_Coin *coin)
     * }
     */
    public static FunctionDescriptor btck_coin_is_coinbase$descriptor() {
        return btck_coin_is_coinbase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_coin_is_coinbase(const btck_Coin *coin)
     * }
     */
    public static MethodHandle btck_coin_is_coinbase$handle() {
        return btck_coin_is_coinbase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_coin_is_coinbase(const btck_Coin *coin)
     * }
     */
    public static MemorySegment btck_coin_is_coinbase$address() {
        return btck_coin_is_coinbase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_coin_is_coinbase(const btck_Coin *coin)
     * }
     */
    public static int btck_coin_is_coinbase(MemorySegment coin) {
        var mh$ = btck_coin_is_coinbase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_coin_is_coinbase", coin);
            }
            return (int)mh$.invokeExact(coin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_coin_get_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_coin_get_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const btck_TransactionOutput *btck_coin_get_output(const btck_Coin *coin)
     * }
     */
    public static FunctionDescriptor btck_coin_get_output$descriptor() {
        return btck_coin_get_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const btck_TransactionOutput *btck_coin_get_output(const btck_Coin *coin)
     * }
     */
    public static MethodHandle btck_coin_get_output$handle() {
        return btck_coin_get_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const btck_TransactionOutput *btck_coin_get_output(const btck_Coin *coin)
     * }
     */
    public static MemorySegment btck_coin_get_output$address() {
        return btck_coin_get_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const btck_TransactionOutput *btck_coin_get_output(const btck_Coin *coin)
     * }
     */
    public static MemorySegment btck_coin_get_output(MemorySegment coin) {
        var mh$ = btck_coin_get_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_coin_get_output", coin);
            }
            return (MemorySegment)mh$.invokeExact(coin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_coin_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_coin_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_coin_destroy(btck_Coin *coin)
     * }
     */
    public static FunctionDescriptor btck_coin_destroy$descriptor() {
        return btck_coin_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_coin_destroy(btck_Coin *coin)
     * }
     */
    public static MethodHandle btck_coin_destroy$handle() {
        return btck_coin_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_coin_destroy(btck_Coin *coin)
     * }
     */
    public static MemorySegment btck_coin_destroy$address() {
        return btck_coin_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_coin_destroy(btck_Coin *coin)
     * }
     */
    public static void btck_coin_destroy(MemorySegment coin) {
        var mh$ = btck_coin_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_coin_destroy", coin);
            }
            mh$.invokeExact(coin);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_hash_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_hash_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_hash_create(const unsigned char block_hash[32])
     * }
     */
    public static FunctionDescriptor btck_block_hash_create$descriptor() {
        return btck_block_hash_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_hash_create(const unsigned char block_hash[32])
     * }
     */
    public static MethodHandle btck_block_hash_create$handle() {
        return btck_block_hash_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_hash_create(const unsigned char block_hash[32])
     * }
     */
    public static MemorySegment btck_block_hash_create$address() {
        return btck_block_hash_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_hash_create(const unsigned char block_hash[32])
     * }
     */
    public static MemorySegment btck_block_hash_create(MemorySegment block_hash) {
        var mh$ = btck_block_hash_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_hash_create", block_hash);
            }
            return (MemorySegment)mh$.invokeExact(block_hash);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_hash_equals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_INT,
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_hash_equals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int btck_block_hash_equals(const btck_BlockHash *hash1, const btck_BlockHash *hash2)
     * }
     */
    public static FunctionDescriptor btck_block_hash_equals$descriptor() {
        return btck_block_hash_equals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int btck_block_hash_equals(const btck_BlockHash *hash1, const btck_BlockHash *hash2)
     * }
     */
    public static MethodHandle btck_block_hash_equals$handle() {
        return btck_block_hash_equals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int btck_block_hash_equals(const btck_BlockHash *hash1, const btck_BlockHash *hash2)
     * }
     */
    public static MemorySegment btck_block_hash_equals$address() {
        return btck_block_hash_equals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int btck_block_hash_equals(const btck_BlockHash *hash1, const btck_BlockHash *hash2)
     * }
     */
    public static int btck_block_hash_equals(MemorySegment hash1, MemorySegment hash2) {
        var mh$ = btck_block_hash_equals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_hash_equals", hash1, hash2);
            }
            return (int)mh$.invokeExact(hash1, hash2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_hash_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_hash_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_hash_copy(const btck_BlockHash *block_hash)
     * }
     */
    public static FunctionDescriptor btck_block_hash_copy$descriptor() {
        return btck_block_hash_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_hash_copy(const btck_BlockHash *block_hash)
     * }
     */
    public static MethodHandle btck_block_hash_copy$handle() {
        return btck_block_hash_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_hash_copy(const btck_BlockHash *block_hash)
     * }
     */
    public static MemorySegment btck_block_hash_copy$address() {
        return btck_block_hash_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * btck_BlockHash *btck_block_hash_copy(const btck_BlockHash *block_hash)
     * }
     */
    public static MemorySegment btck_block_hash_copy(MemorySegment block_hash) {
        var mh$ = btck_block_hash_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_hash_copy", block_hash);
            }
            return (MemorySegment)mh$.invokeExact(block_hash);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_hash_to_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER,
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_hash_to_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_block_hash_to_bytes(const btck_BlockHash *block_hash, unsigned char output[32])
     * }
     */
    public static FunctionDescriptor btck_block_hash_to_bytes$descriptor() {
        return btck_block_hash_to_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_block_hash_to_bytes(const btck_BlockHash *block_hash, unsigned char output[32])
     * }
     */
    public static MethodHandle btck_block_hash_to_bytes$handle() {
        return btck_block_hash_to_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_block_hash_to_bytes(const btck_BlockHash *block_hash, unsigned char output[32])
     * }
     */
    public static MemorySegment btck_block_hash_to_bytes$address() {
        return btck_block_hash_to_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_block_hash_to_bytes(const btck_BlockHash *block_hash, unsigned char output[32])
     * }
     */
    public static void btck_block_hash_to_bytes(MemorySegment block_hash, MemorySegment output) {
        var mh$ = btck_block_hash_to_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_hash_to_bytes", block_hash, output);
            }
            mh$.invokeExact(block_hash, output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class btck_block_hash_destroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            bitcoinkernel_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("btck_block_hash_destroy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void btck_block_hash_destroy(btck_BlockHash *block_hash)
     * }
     */
    public static FunctionDescriptor btck_block_hash_destroy$descriptor() {
        return btck_block_hash_destroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void btck_block_hash_destroy(btck_BlockHash *block_hash)
     * }
     */
    public static MethodHandle btck_block_hash_destroy$handle() {
        return btck_block_hash_destroy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void btck_block_hash_destroy(btck_BlockHash *block_hash)
     * }
     */
    public static MemorySegment btck_block_hash_destroy$address() {
        return btck_block_hash_destroy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void btck_block_hash_destroy(btck_BlockHash *block_hash)
     * }
     */
    public static void btck_block_hash_destroy(MemorySegment block_hash) {
        var mh$ = btck_block_hash_destroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("btck_block_hash_destroy", block_hash);
            }
            mh$.invokeExact(block_hash);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = bitcoinkernel_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final byte btck_SynchronizationState_INIT_REINDEX = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define btck_SynchronizationState_INIT_REINDEX 0
     * }
     */
    public static byte btck_SynchronizationState_INIT_REINDEX() {
        return btck_SynchronizationState_INIT_REINDEX;
    }
    private static final byte btck_SynchronizationState_INIT_DOWNLOAD = (byte)1L;
    /**
     * {@snippet lang=c :
     * #define btck_SynchronizationState_INIT_DOWNLOAD 1
     * }
     */
    public static byte btck_SynchronizationState_INIT_DOWNLOAD() {
        return btck_SynchronizationState_INIT_DOWNLOAD;
    }
    private static final byte btck_SynchronizationState_POST_INIT = (byte)2L;
    /**
     * {@snippet lang=c :
     * #define btck_SynchronizationState_POST_INIT 2
     * }
     */
    public static byte btck_SynchronizationState_POST_INIT() {
        return btck_SynchronizationState_POST_INIT;
    }
    private static final byte btck_Warning_UNKNOWN_NEW_RULES_ACTIVATED = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define btck_Warning_UNKNOWN_NEW_RULES_ACTIVATED 0
     * }
     */
    public static byte btck_Warning_UNKNOWN_NEW_RULES_ACTIVATED() {
        return btck_Warning_UNKNOWN_NEW_RULES_ACTIVATED;
    }
    private static final byte btck_Warning_LARGE_WORK_INVALID_CHAIN = (byte)1L;
    /**
     * {@snippet lang=c :
     * #define btck_Warning_LARGE_WORK_INVALID_CHAIN 1
     * }
     */
    public static byte btck_Warning_LARGE_WORK_INVALID_CHAIN() {
        return btck_Warning_LARGE_WORK_INVALID_CHAIN;
    }
    private static final byte btck_ValidationMode_VALID = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define btck_ValidationMode_VALID 0
     * }
     */
    public static byte btck_ValidationMode_VALID() {
        return btck_ValidationMode_VALID;
    }
    private static final byte btck_ValidationMode_INVALID = (byte)1L;
    /**
     * {@snippet lang=c :
     * #define btck_ValidationMode_INVALID 1
     * }
     */
    public static byte btck_ValidationMode_INVALID() {
        return btck_ValidationMode_INVALID;
    }
    private static final byte btck_ValidationMode_INTERNAL_ERROR = (byte)2L;
    /**
     * {@snippet lang=c :
     * #define btck_ValidationMode_INTERNAL_ERROR 2
     * }
     */
    public static byte btck_ValidationMode_INTERNAL_ERROR() {
        return btck_ValidationMode_INTERNAL_ERROR;
    }
    private static final int btck_BlockValidationResult_UNSET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_UNSET 0
     * }
     */
    public static int btck_BlockValidationResult_UNSET() {
        return btck_BlockValidationResult_UNSET;
    }
    private static final int btck_BlockValidationResult_CONSENSUS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_CONSENSUS 1
     * }
     */
    public static int btck_BlockValidationResult_CONSENSUS() {
        return btck_BlockValidationResult_CONSENSUS;
    }
    private static final int btck_BlockValidationResult_CACHED_INVALID = (int)2L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_CACHED_INVALID 2
     * }
     */
    public static int btck_BlockValidationResult_CACHED_INVALID() {
        return btck_BlockValidationResult_CACHED_INVALID;
    }
    private static final int btck_BlockValidationResult_INVALID_HEADER = (int)3L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_INVALID_HEADER 3
     * }
     */
    public static int btck_BlockValidationResult_INVALID_HEADER() {
        return btck_BlockValidationResult_INVALID_HEADER;
    }
    private static final int btck_BlockValidationResult_MUTATED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_MUTATED 4
     * }
     */
    public static int btck_BlockValidationResult_MUTATED() {
        return btck_BlockValidationResult_MUTATED;
    }
    private static final int btck_BlockValidationResult_MISSING_PREV = (int)5L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_MISSING_PREV 5
     * }
     */
    public static int btck_BlockValidationResult_MISSING_PREV() {
        return btck_BlockValidationResult_MISSING_PREV;
    }
    private static final int btck_BlockValidationResult_INVALID_PREV = (int)6L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_INVALID_PREV 6
     * }
     */
    public static int btck_BlockValidationResult_INVALID_PREV() {
        return btck_BlockValidationResult_INVALID_PREV;
    }
    private static final int btck_BlockValidationResult_TIME_FUTURE = (int)7L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_TIME_FUTURE 7
     * }
     */
    public static int btck_BlockValidationResult_TIME_FUTURE() {
        return btck_BlockValidationResult_TIME_FUTURE;
    }
    private static final int btck_BlockValidationResult_HEADER_LOW_WORK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define btck_BlockValidationResult_HEADER_LOW_WORK 8
     * }
     */
    public static int btck_BlockValidationResult_HEADER_LOW_WORK() {
        return btck_BlockValidationResult_HEADER_LOW_WORK;
    }
    private static final byte btck_LogCategory_ALL = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_ALL 0
     * }
     */
    public static byte btck_LogCategory_ALL() {
        return btck_LogCategory_ALL;
    }
    private static final byte btck_LogCategory_BENCH = (byte)1L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_BENCH 1
     * }
     */
    public static byte btck_LogCategory_BENCH() {
        return btck_LogCategory_BENCH;
    }
    private static final byte btck_LogCategory_BLOCKSTORAGE = (byte)2L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_BLOCKSTORAGE 2
     * }
     */
    public static byte btck_LogCategory_BLOCKSTORAGE() {
        return btck_LogCategory_BLOCKSTORAGE;
    }
    private static final byte btck_LogCategory_COINDB = (byte)3L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_COINDB 3
     * }
     */
    public static byte btck_LogCategory_COINDB() {
        return btck_LogCategory_COINDB;
    }
    private static final byte btck_LogCategory_LEVELDB = (byte)4L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_LEVELDB 4
     * }
     */
    public static byte btck_LogCategory_LEVELDB() {
        return btck_LogCategory_LEVELDB;
    }
    private static final byte btck_LogCategory_MEMPOOL = (byte)5L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_MEMPOOL 5
     * }
     */
    public static byte btck_LogCategory_MEMPOOL() {
        return btck_LogCategory_MEMPOOL;
    }
    private static final byte btck_LogCategory_PRUNE = (byte)6L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_PRUNE 6
     * }
     */
    public static byte btck_LogCategory_PRUNE() {
        return btck_LogCategory_PRUNE;
    }
    private static final byte btck_LogCategory_RAND = (byte)7L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_RAND 7
     * }
     */
    public static byte btck_LogCategory_RAND() {
        return btck_LogCategory_RAND;
    }
    private static final byte btck_LogCategory_REINDEX = (byte)8L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_REINDEX 8
     * }
     */
    public static byte btck_LogCategory_REINDEX() {
        return btck_LogCategory_REINDEX;
    }
    private static final byte btck_LogCategory_VALIDATION = (byte)9L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_VALIDATION 9
     * }
     */
    public static byte btck_LogCategory_VALIDATION() {
        return btck_LogCategory_VALIDATION;
    }
    private static final byte btck_LogCategory_KERNEL = (byte)10L;
    /**
     * {@snippet lang=c :
     * #define btck_LogCategory_KERNEL 10
     * }
     */
    public static byte btck_LogCategory_KERNEL() {
        return btck_LogCategory_KERNEL;
    }
    private static final byte btck_LogLevel_TRACE = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define btck_LogLevel_TRACE 0
     * }
     */
    public static byte btck_LogLevel_TRACE() {
        return btck_LogLevel_TRACE;
    }
    private static final byte btck_LogLevel_DEBUG = (byte)1L;
    /**
     * {@snippet lang=c :
     * #define btck_LogLevel_DEBUG 1
     * }
     */
    public static byte btck_LogLevel_DEBUG() {
        return btck_LogLevel_DEBUG;
    }
    private static final byte btck_LogLevel_INFO = (byte)2L;
    /**
     * {@snippet lang=c :
     * #define btck_LogLevel_INFO 2
     * }
     */
    public static byte btck_LogLevel_INFO() {
        return btck_LogLevel_INFO;
    }
    private static final byte btck_ScriptVerifyStatus_OK = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerifyStatus_OK 0
     * }
     */
    public static byte btck_ScriptVerifyStatus_OK() {
        return btck_ScriptVerifyStatus_OK;
    }
    private static final byte btck_ScriptVerifyStatus_ERROR_INVALID_FLAGS_COMBINATION = (byte)1L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerifyStatus_ERROR_INVALID_FLAGS_COMBINATION 1
     * }
     */
    public static byte btck_ScriptVerifyStatus_ERROR_INVALID_FLAGS_COMBINATION() {
        return btck_ScriptVerifyStatus_ERROR_INVALID_FLAGS_COMBINATION;
    }
    private static final byte btck_ScriptVerifyStatus_ERROR_SPENT_OUTPUTS_REQUIRED = (byte)2L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerifyStatus_ERROR_SPENT_OUTPUTS_REQUIRED 2
     * }
     */
    public static byte btck_ScriptVerifyStatus_ERROR_SPENT_OUTPUTS_REQUIRED() {
        return btck_ScriptVerifyStatus_ERROR_SPENT_OUTPUTS_REQUIRED;
    }
    private static final int btck_ScriptVerificationFlags_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_NONE 0
     * }
     */
    public static int btck_ScriptVerificationFlags_NONE() {
        return btck_ScriptVerificationFlags_NONE;
    }
    private static final int btck_ScriptVerificationFlags_P2SH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_P2SH 1
     * }
     */
    public static int btck_ScriptVerificationFlags_P2SH() {
        return btck_ScriptVerificationFlags_P2SH;
    }
    private static final int btck_ScriptVerificationFlags_DERSIG = (int)4L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_DERSIG 4
     * }
     */
    public static int btck_ScriptVerificationFlags_DERSIG() {
        return btck_ScriptVerificationFlags_DERSIG;
    }
    private static final int btck_ScriptVerificationFlags_NULLDUMMY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_NULLDUMMY 16
     * }
     */
    public static int btck_ScriptVerificationFlags_NULLDUMMY() {
        return btck_ScriptVerificationFlags_NULLDUMMY;
    }
    private static final int btck_ScriptVerificationFlags_CHECKLOCKTIMEVERIFY = (int)512L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_CHECKLOCKTIMEVERIFY 512
     * }
     */
    public static int btck_ScriptVerificationFlags_CHECKLOCKTIMEVERIFY() {
        return btck_ScriptVerificationFlags_CHECKLOCKTIMEVERIFY;
    }
    private static final int btck_ScriptVerificationFlags_CHECKSEQUENCEVERIFY = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_CHECKSEQUENCEVERIFY 1024
     * }
     */
    public static int btck_ScriptVerificationFlags_CHECKSEQUENCEVERIFY() {
        return btck_ScriptVerificationFlags_CHECKSEQUENCEVERIFY;
    }
    private static final int btck_ScriptVerificationFlags_WITNESS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_WITNESS 2048
     * }
     */
    public static int btck_ScriptVerificationFlags_WITNESS() {
        return btck_ScriptVerificationFlags_WITNESS;
    }
    private static final int btck_ScriptVerificationFlags_TAPROOT = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_TAPROOT 131072
     * }
     */
    public static int btck_ScriptVerificationFlags_TAPROOT() {
        return btck_ScriptVerificationFlags_TAPROOT;
    }
    private static final int btck_ScriptVerificationFlags_ALL = (int)134677L;
    /**
     * {@snippet lang=c :
     * #define btck_ScriptVerificationFlags_ALL 134677
     * }
     */
    public static int btck_ScriptVerificationFlags_ALL() {
        return btck_ScriptVerificationFlags_ALL;
    }
    private static final byte btck_ChainType_MAINNET = (byte)0L;
    /**
     * {@snippet lang=c :
     * #define btck_ChainType_MAINNET 0
     * }
     */
    public static byte btck_ChainType_MAINNET() {
        return btck_ChainType_MAINNET;
    }
    private static final byte btck_ChainType_TESTNET = (byte)1L;
    /**
     * {@snippet lang=c :
     * #define btck_ChainType_TESTNET 1
     * }
     */
    public static byte btck_ChainType_TESTNET() {
        return btck_ChainType_TESTNET;
    }
    private static final byte btck_ChainType_TESTNET_4 = (byte)2L;
    /**
     * {@snippet lang=c :
     * #define btck_ChainType_TESTNET_4 2
     * }
     */
    public static byte btck_ChainType_TESTNET_4() {
        return btck_ChainType_TESTNET_4;
    }
    private static final byte btck_ChainType_SIGNET = (byte)3L;
    /**
     * {@snippet lang=c :
     * #define btck_ChainType_SIGNET 3
     * }
     */
    public static byte btck_ChainType_SIGNET() {
        return btck_ChainType_SIGNET;
    }
    private static final byte btck_ChainType_REGTEST = (byte)4L;
    /**
     * {@snippet lang=c :
     * #define btck_ChainType_REGTEST 4
     * }
     */
    public static byte btck_ChainType_REGTEST() {
        return btck_ChainType_REGTEST;
    }
}

